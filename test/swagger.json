{
    "swagger": "2.0",
    "basePath": "/api/v1",
    "paths": {
        "/analysis/audio_signal_status/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/AudioSignalStatus"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves current status of audio signal from BATS Core",
                "description": "SDK: `get_audio_signal_status()`\n\nNotes:\n * Audio signal status is mostly as reported by Magewell HDMI capture hardware.",
                "operationId": "get_audio_signal_status",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/audio_silent/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Number of consecutive frames reckoned as \"identical\" in the stream, including most recent frame\n         (0 => stream is not stationary)",
                        "schema": {
                            "type": "integer"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Uses BATS Core to determine how many consecutive frames in the device video stream are currently \"silent\"",
                "description": "SDK: `get_audio_silent()`\n\nNotes:\n * See set_analyzer_setting() for settings that may affect the definition of audio frame silence.",
                "operationId": "get_audio_silent",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/audio_stats/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/AudioStats"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves current audio statistics from BATS Core",
                "description": "SDK: `get_audio_stats()`",
                "operationId": "get_audio_stats",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/ffwd_play_time/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Play time matched, converted to linear seconds (None => no play time found)",
                        "schema": {
                            "type": "integer"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Captures a screenshot and performs OCR matching for the play time on the bottom portion of the frame,         presuming that playback is being fast-forwarded",
                "description": "SDK: `get_ffwd_play_time()`",
                "operationId": "get_ffwd_play_time",
                "parameters": [
                    {
                        "name": "retries",
                        "in": "query",
                        "type": "integer",
                        "description": "Number of times to retry OCR matching if unsuccessful",
                        "default": 5
                    }
                ],
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/frame_number/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Current frame number",
                        "schema": {
                            "type": "integer"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Returns the current frame count for the video device, initialized to 0 at device worker startup",
                "description": "SDK: `get_frame_number()`",
                "operationId": "get_frame_number",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/get_cc_text/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Closed captioning text (if any) extracted from frame image, or (if `capture`) tuple containing\n         captioning text and image capture filespec",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Captures a snapshot of the current screen frame, or uses a previously captured frame snapshot, and         uses OCR to extract the Closed Captioning (CC) text, if any, contained on the screen",
                "description": "SDK: `get_cc_text()`",
                "operationId": "get_cc_text",
                "parameters": [
                    {
                        "name": "image",
                        "in": "formData",
                        "type": "string",
                        "description": "File specification (on EAPI server) for frame image file or frame image content (base64-encoded)\n                (None => capture snapshot of current screen frame)"
                    },
                    {
                        "name": "capture",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Also return capture filespec of snapshot from which CC text is extracted.\"",
                        "default": false
                    }
                ],
                "security": [],
                "consumes": [
                    "application/x-www-form-urlencoded",
                    "multipart/form-data"
                ],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/get_image_text/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Text (if any) extracted from frame image, or (if `capture`) tuple containing text and image capture\n         filespec",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Captures a snapshot of the current screen frame, or uses a previously captured frame snapshot, and         uses OCR to extract the text, if any, contained on the screen",
                "description": "SDK: `get_image_text()`",
                "operationId": "get_image_text",
                "parameters": [
                    {
                        "name": "image",
                        "in": "formData",
                        "type": "string",
                        "description": "File specification (on EAPI server) for frame image file or frame image content (base64-encoded)\n                (None => capture snapshot of current screen frame)"
                    },
                    {
                        "name": "capture",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Also return capture filespec of snapshot from which text is extracted, if applicable.\"",
                        "default": false
                    }
                ],
                "security": [],
                "consumes": [
                    "application/x-www-form-urlencoded",
                    "multipart/form-data"
                ],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/is_audio_muted/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "\"Audio is currently deemed 'muted' as observed by the BATS Core.\"",
                        "schema": {
                            "type": "boolean"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Determines if audio appears to be \"muted\" (i\u2024e\u2024, \"silent\" for a continuous duration)",
                "description": "SDK: `is_audio_muted()`\n\nNotes:\n * The threshold for the number of consecutive \"silent\" audio frames detected in order to consider the\n   stream as \"muted\" is governed by the `mute_threshold` analyzer setting (see `set_analyzer_setting()`)",
                "operationId": "is_audio_muted",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/is_video_black/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "\"Video frame is currently deemed 'black' as observed by the BATS Core.\"",
                        "schema": {
                            "type": "boolean"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Determines if video display appears to currently be all \"black\"",
                "description": "SDK: `is_video_black()`\n\nNotes:\n * The greyscale threshold for the luminance level, below which a frame is considered \"black\", is governed\n   by the `black_threshold` analyzer setting (see `set_analyzer_setting()`)",
                "operationId": "is_video_black",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/is_video_frozen/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "\"Video is currently deemed 'frozen' as observed by the BATS Core.\"",
                        "schema": {
                            "type": "boolean"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Determines if video appears to be \"frozen\" (i\u2024e\u2024, playing the same substantially identical frame continuously)",
                "description": "SDK: `is_video_frozen()`\n\nNotes:\n * The threshold for the number of consecutive \"identical\" video frames detected in order to consider the\n   stream as \"frozen\" is governed by the `frozen_threshold` analyzer setting (see `set_analyzer_setting()`)",
                "operationId": "is_video_frozen",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/option_selected/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Menu option highlighted (None => menu not detected)",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Captures a snapshot of the current screen frame and analyzes it to determine which menu option is currently         highlighted on the onscreen menu (if present and recognizable)",
                "description": "SDK: `get_option_selected()`\n\nNotes:\n * Default file specification is a device-specific and timestamped variation of 'episode_menu.jpg'.",
                "operationId": "get_option_selected",
                "parameters": [
                    {
                        "name": "filespec",
                        "in": "query",
                        "type": "string",
                        "description": "File specification where to store current screen frame captured (None => default capture file)"
                    }
                ],
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/quick_channel_number/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Channel number extracted (None => channel number not detected)",
                        "schema": {
                            "type": "integer"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Captures a snapshot of the current screen frame and uses OCR on a predefined ROI to retrieve the channel         number (if present and recognizable) from it",
                "description": "SDK: `get_quick_channel_number()`\n\nNotes:\n * Default file specification is a device-specific and timestamped variation of 'channel.jpg'.\n * The player must be displaying the XRE Info page in order for the channel number to be extractable\n   (press [INFO] button or otherwise navigate to this page beforehand).\n * This algorithm is sensitive to frame size and channel number position within the frame --\n   currently only implemented for STBs.",
                "operationId": "get_quick_channel_number",
                "parameters": [
                    {
                        "name": "filespec",
                        "in": "query",
                        "type": "string",
                        "description": "File specification where to store current screen frame captured (None => default capture file)"
                    }
                ],
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/reset_audio_stats/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Resets tabulation values for audio statistics within BATS Core",
                "description": "SDK: `reset_audio_stats()`",
                "operationId": "reset_audio_stats",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/reset_video_stats/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Resets tabulation values for video statistics within BATS Core",
                "description": "SDK: `reset_video_stats()`",
                "operationId": "reset_video_stats",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/score_brisque/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "BRISQUE scores for stream image frames, one per scoring period",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "array",
                                "items": {
                                    "type": "object"
                                }
                            }
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Performs BRISQUE image quality scoring on an ROI in the current stream for a fixed time duration",
                "description": "SDK: `do_score_brisque()`\n\nNotes:\n * The ROI to be scored in the stream is defined on-the-fly, and thus needn't be predefined in the current\n   ROI definitions file.\n * An image score is produced for each scoring period in the scoring interval, where the period is determined\n   arbitrarily, but is no more frequent than 2 Hz.",
                "operationId": "do_score_brisque",
                "parameters": [
                    {
                        "name": "duration",
                        "in": "query",
                        "type": "number",
                        "description": "Duration (sec) to perform BRISQUE scoring",
                        "default": 30
                    }
                ],
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/screenshot/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Serialized (base-64) representation of screen frame image ('content'==True),\n         Raw binary content of the frame image ('content'==True, 'binary'==True),\n         or filespec containing image ('content'==False)",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Captures and returns a snapshot of the current screen frame from the stream capture hardware",
                "description": "SDK: `get_screenshot()`\n\nNotes:\n * Use `device_api.get_screenshot()` to capture the image using any existing device category-specific facility.\n * See `capture_screenshot()` for the default file specification.",
                "operationId": "get_screenshot",
                "parameters": [
                    {
                        "name": "filename",
                        "in": "query",
                        "type": "string",
                        "description": "File specification where to store current screen frame captured (None => default capture file)"
                    },
                    {
                        "name": "content",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Return encoded BLOB containing frame content.\"  (else return filespec where content is stored)",
                        "default": true
                    },
                    {
                        "name": "binary",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Return frame content in raw binary form. (iff content == true)\"",
                        "default": false
                    }
                ],
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/setting/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Current setting value",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Gets the current value for an operational setting used by the BATS Core frame analyzer",
                "description": "SDK: `get_setting()`",
                "operationId": "get_setting",
                "parameters": [
                    {
                        "name": "setting",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Setting to retrieve -- see `AnalyzerSettings` model"
                    }
                ],
                "security": [],
                "tags": [
                    "analysis"
                ]
            },
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Sets an operational setting used by the BATS Core frame analyzer",
                "description": "SDK: `set_setting()`",
                "operationId": "set_setting",
                "parameters": [
                    {
                        "name": "setting",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Setting to affect -- see `AnalyzerSettings` model"
                    },
                    {
                        "name": "value",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Setting value to set"
                    }
                ],
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/spoken_language_info/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/SpokenLanguageInfo"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Captures an audio clip from the current stream and performs NLP to determine characteristics of spoken words present, as possible",
                "description": "SDK: `get_spoken_language_info()`",
                "operationId": "get_spoken_language_info",
                "parameters": [
                    {
                        "name": "duration",
                        "in": "query",
                        "type": "number",
                        "description": "Duration (sec) for audio capture",
                        "default": 10
                    }
                ],
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/start_recording/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "File specification where recording is being written",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Initiates frame-by-frame recording of all video frames for this player device, writing the recording to         a local file on this server system",
                "description": "SDK: `do_start_recording()`\n\nNotes:\n * Default file specification includes a device-specific directory and unique name with a '.webm' extension.\n * Only one recording can be in progress at any given time for each device.\n * See `stop_recording()` to discontinue stream recording.\n * Any recording in progress will be discontinued automatically when this player device abstraction object\n   is destroyed.",
                "operationId": "do_start_recording",
                "parameters": [
                    {
                        "name": "filespec",
                        "in": "query",
                        "type": "string",
                        "description": "File specification where to store recorded video stream (None => create unique recording file)"
                    }
                ],
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/stop_recording/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Discontinues any stream recording currently in progress on this player device",
                "description": "SDK: `do_stop_recording()`",
                "operationId": "do_stop_recording",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/video_signal_status/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/VideoSignalStatus"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves current status of video signal from BATS Core",
                "description": "SDK: `get_video_signal_status()`\n\nNotes:\n * Video signal status is mostly as reported by Magewell HDMI capture hardware.",
                "operationId": "get_video_signal_status",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/video_similarity/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "\"Similarity\" (%) of frame to predecessor",
                        "schema": {
                            "type": "number"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves how similar the current frame captured from the device video stream is to its predecessor",
                "description": "SDK: `get_video_similarity()`\n\nNotes:\n * See set_analyzer_setting() for settings that may affect the definition of video frame comparison.",
                "operationId": "get_video_similarity",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/video_stationary/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Number of consecutive frames reckoned as \"identical\" in the stream, including most recent frame\n         (0 => stream is not stationary)",
                        "schema": {
                            "type": "integer"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Uses BATS Core to determine how many consecutive frames in the device video stream are currently \"identical\"",
                "description": "SDK: `get_video_stationary()`\n\nNotes:\n * Depending upon BATS Core analyzer settings, the stream may appear stationary when a \"still\" image is\n   being presented within the stream content, which is a routine occurrence; it is up to the caller to\n   determine if this is a true indication of a \"frozen\" stream or not.\n * See set_analyzer_setting() for settings that may affect the definition of video frame comparison.",
                "operationId": "get_video_stationary",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/analysis/video_stats/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/VideoStats"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves current video statistics from BATS Core",
                "description": "SDK: `get_video_stats()`",
                "operationId": "get_video_stats",
                "security": [],
                "tags": [
                    "analysis"
                ]
            }
        },
        "/device/channel_map/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Channel map:\n          key: call sign, value: numerical channel",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves provider channel map for account by which device is authorized",
                "description": "SDK: `get_channel_map()`\n\nNotes:\n<br>... [STB]\n * Channel map is ordered as extracted from XAPI, probably numerically.",
                "operationId": "get_channel_map",
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/collect_logs/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Result pair:\n          [0] Server-side filespec where BLOB is stored\n          [1] Serialized (base-64) representation of encoded BLOB ('content'==True); empty for `content`==False",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves a device category-specific collection of logs from the player device, stores them on the server         filesystem, and optionally retrieves their content as a BLOB",
                "description": "SDK: `get_logs()`\n\nNotes:\n * May be size-limited by HTTP-based transmission interface when retrieving log content; recommended to use\n   'file_upload' for large files instead.\n\n<br>... [STB]\n    * `filespec`==None => retrieve canonical set of STB logs as a .tar.gz file\n\n<br>... [SSP]\n * `filespec`==None => retrieve canonical set of SSPC Hub logs as a tar.gz file",
                "operationId": "get_logs",
                "parameters": [
                    {
                        "name": "filespec",
                        "in": "query",
                        "type": "string",
                        "description": "File specification for a file on the player device filesystem where the logs are stored\n                 (None => retrieve a canonical set of logs specific to the device category)"
                    },
                    {
                        "name": "content",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Return BLOB containing collected log content.\"\n                 (else return server filespec where content is stored)",
                        "default": true
                    },
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Timeout period (sec) allowed for log retrieval from STB (None => unlimited duration)"
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/device_code_version/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Firmware version(s) loaded on the STB (keys are components, values are version strings)",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves the version(s) for all applicable code/firmware currently loaded on this player device",
                "description": "SDK: `get_device_code_version()`\n\nNotes:\n<br>... [STB]\n * Sole code version retrieved is for the operating RDK firmware.",
                "operationId": "get_device_code_version",
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/device_details/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Detailed device information dictionary",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves and returns device-specific information, some of which may be queried from external services",
                "description": "SDK: `get_device_details()`\n\nNotes:\n<br>... [STB]\n * For xSearch to return network info for a partner device on the Comcast network, it's necessary to search\n   via eSTB MAC with partner='comcast' (not via x1 Device ID).",
                "operationId": "get_device_details",
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/enter_text/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "\"Button presses appear to be successful.\"",
                        "schema": {
                            "type": "boolean"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Enters text into the current UI input element, if applicable, optionally followed by pressing the ENTER key         (button)",
                "description": "SDK: `do_enter_text()`\n\nNotes:\n<br>... [STB]\n * Only numeric text entry is supported at this time.\n * If applicable, uses the IR blaster channel dedicated to this device to enter the sequence of numeric digits\n   using its remote control.",
                "operationId": "do_enter_text",
                "parameters": [
                    {
                        "name": "text",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Text to enter (when numeric, specify as a string for leading zeroes)"
                    },
                    {
                        "name": "numeric",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"`text` must be numeric.\"",
                        "default": false
                    },
                    {
                        "name": "enter",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Press ENTER (a.k.a. OK) button after entering text.\"",
                        "default": false
                    },
                    {
                        "name": "press_delay",
                        "in": "query",
                        "type": "number",
                        "description": "[STB] Pacing duration (sec) to delay between pressing buttons",
                        "default": 0.8
                    },
                    {
                        "name": "enter_delay",
                        "in": "query",
                        "type": "number",
                        "description": "[STB] Pacing duration (sec) to delay after pressing all buttons",
                        "default": 2
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/exit/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Performs any device-specific termination or closure to cede usage of the player device",
                "description": "SDK: `do_exit_device()`\n\nNotes:\n * If there is a resource request in progress on the player device, the `exit` resource will cause that\n   outstanding request to become terminated immediately and its HTTP status returned as 410 GONE.",
                "operationId": "do_exit_device",
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/file_download/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Downloads a file from the local BATS Server filesystem to a specified destination on the player device",
                "description": "SDK: `do_file_download()`\n\n:raises: PlayerParameterError if local file is inaccessible\n:raises: PlayerDeviceError if download to STB fails\n\nNotes:\n * CAUTION: Specifying None for `timeout` can hang this request execution perpetually.\n\n<br>... [STB]\n * For a multi-stage file transfer (through a Jump Server), the timeout applies to each stage, per retry.",
                "operationId": "do_file_download",
                "parameters": [
                    {
                        "name": "local_filespec",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "File specification for source file on the local filesystem (representable as a str)"
                    },
                    {
                        "name": "device_filespec",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "File specification for destination file on the STB"
                    },
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Timeout period (sec) allowed for file transfer (None => unlimited duration)"
                    },
                    {
                        "name": "overwrite",
                        "in": "query",
                        "type": "boolean",
                        "description": "[STB] \"Overwrites destination file on STB if it already exists.\" (otherwise fails)",
                        "default": true
                    },
                    {
                        "name": "verify",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Requires file content verification to succeed.\"\n                  (otherwise verifies content, but does not fail on mismatch)",
                        "default": false
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/file_upload/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Uploads a file from the player device to a specified destination on the local BATS Server filesystem",
                "description": "SDK: `do_file_upload()`\n\n:raises: PlayerParameterError if local file is inaccessible\n:raises: PlayerDeviceError if upload from STB fails\n\nNotes:\n * CAUTION: Specifying None for `timeout` can hang this request execution perpetually.\n\n<br>... [STB]\n * For a multi-stage file transfer (through a Jump Server), the timeout applies to each stage, per retry.",
                "operationId": "do_file_upload",
                "parameters": [
                    {
                        "name": "device_filespec",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "File specification for source file on the STB"
                    },
                    {
                        "name": "local_filespec",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "File specification for destination file on the local filesystem (representable as a str)"
                    },
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Timeout period (sec) allowed for file transfer (None => unlimited duration)"
                    },
                    {
                        "name": "overwrite",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Allow overwrite of local file.\"",
                        "default": true
                    },
                    {
                        "name": "verify",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Requires file content verification to succeed.\"\n                  (otherwise verifies content, but does not fail on mismatch)",
                        "default": false
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/firmware_install/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Result:\n          [0]: Outcome: SUCCESS/FAIL\n          [1]: Explanatory message\n          [2]: Time (sec) taken to download/reinitialize\n          [3]: Firmware version",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Installs specified firmware version on the player device",
                "description": "SDK: `do_firmware_install()`\n\n:raises: ServiceNetworkError if needed network infrastructure or resource is unavailable\n                             (e.g., RDK Portal, CDL Server, firmware image, etc.)\n:raises: PlayerParameterError if a download parameter is misspecified\n:raises: PlayerDeviceError if a necessary attribute is incorrect or an internal processing error occurred\n\nNotes:\n * Specified timeout is approximate; download procedure may take longer than this timeout due to ancillary\n   command execution.\n\n<br>... [STB]\n * RDK firmware image is installed using the whatever installation method is defined for the STB device type.\n * When no `image_dir` is specified, the RDK image is downloaded directly by the device from the Comcast\n   Code DownLoad (CDL) server.  The CDL server only caches a subset of images available from the RDK Portal;\n   acquire the desired image RDK Portal manually and specify an explicit `image_dir` if retrieval of the image\n   from the CDL server fails.",
                "operationId": "do_firmware_install",
                "parameters": [
                    {
                        "name": "image_file",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name of firmware image file to install"
                    },
                    {
                        "name": "image_dir",
                        "in": "query",
                        "type": "string",
                        "description": "Local directory where image file resides (None => download image file from code server)"
                    },
                    {
                        "name": "force",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Install firmware even if it appears that device has the same version installed.\"",
                        "default": false
                    },
                    {
                        "name": "ignore_mismatch",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Install firmware even if its filename prefix mismatches this device make/model.\"",
                        "default": false
                    },
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Timeout period (sec) allowed for entire download/installation procedure\n                        (None => unlimited duration)",
                        "default": 600
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/identify_make_model_variant/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Identifier indicating player device make/model/variant",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Interacts with the player device to infer its specific make/model/variant, and verify that it identifies         itself as expected",
                "description": "SDK: `do_identify_make_model_variant()`\n\nNotes:\n<br>... [STB]\n * Uses the STB shell prompt to verify the actual make/model/variant.",
                "operationId": "do_identify_make_model_variant",
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/init/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/DeviceDefinition"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Performs any device-specific on-device initialization to restore the player device to a known canonical state         in preparation for its use in an auditing/testing scenario",
                "description": "SDK: `do_init_device()`\n\nNotes:\n<br>... [STB]\n  * Optionally establishes and activates the communications interface with the STB device, initializes the XAPI\n    client, and performs any on-device initialization to initialize or restore the STB to a generic state.\n  * If an alternate XAPI is specified, it may also require an alternate associated XRE to be specified as an\n    override in the STB receiver configuration file; doing this is not the responsibility of the EAPI.\n\n<br>... [SSP]\n * Establishes and activates a session with the SSPC device driver, logs in to the SSP device via the driver,\n   and performs any on-device initialization to initialize or restore the SSP to a generic state.\n * `capabilities` includes all options for SSPC and the applications it manages, and may be specified in one\n   of these ways:\n    - as JSON, or\n    - as a newline- or ','-delimited sequence of key=value pairs, or\n    - as a '@'-prefixed file specification for a file containing either of the above",
                "operationId": "do_init_device",
                "parameters": [
                    {
                        "name": "strict",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Only permit initialization of device if it is fully quiescent (not already initialized).\"",
                        "default": false
                    },
                    {
                        "name": "reboot",
                        "in": "query",
                        "type": "boolean",
                        "description": "[STB] \"Perform a warm reboot of the entire device first.\"",
                        "default": false
                    },
                    {
                        "name": "restart_receiver",
                        "in": "query",
                        "type": "boolean",
                        "description": "[STB] \"Perform a reset of the STB receiver component first.\" (ignored if `reboot` specified)",
                        "default": false
                    },
                    {
                        "name": "force_playback",
                        "in": "query",
                        "type": "boolean",
                        "description": "[STB] \"Take action to emerge from Idle or clear dialog, back to active content playback.\"",
                        "default": true
                    },
                    {
                        "name": "no_shell",
                        "in": "query",
                        "type": "boolean",
                        "description": "[STB] \"Circumvent establishing shell session (debug only).\"",
                        "default": false
                    },
                    {
                        "name": "use_xapi",
                        "in": "query",
                        "type": "string",
                        "description": "XAPI variant to use:\n                            False => no XAPI usage (debug only)\n                            True => default (normal) production XAPI, as configured\n                            or one of: {'eas', 'prod', 'ci'}\n                            (may also be full base URL for XAPI service)",
                        "default": "True"
                    },
                    {
                        "name": "no_cache",
                        "in": "query",
                        "type": "boolean",
                        "description": "[STB] \"Ignore cached dynamic device info and explicitly retrieve afresh from xSearch API.\"",
                        "default": false
                    },
                    {
                        "name": "ssp_player_app",
                        "in": "query",
                        "type": "string",
                        "description": "Embedded SSP application/stack doing player control ('PP' or 'XS'):\n                         PP: VIPER Player Platform @@@@ Deprecated\n                         XS: Xfinity Stream app",
                        "default": "XS"
                    },
                    {
                        "name": "ssp_player_build",
                        "in": "query",
                        "type": "string",
                        "description": "[SSP] Build for SSP player app/stack, if applicable ('dev' or 'prod')",
                        "default": "prod"
                    },
                    {
                        "name": "capabilities",
                        "in": "query",
                        "type": "string",
                        "description": "Overrides for SSP device capabilities\n                         (unspecified => use configured/default capabilities)"
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/navigate/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Error message from navigation operation (empty => success)",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Navigates directly to a specified \"bookmark\" in the device user interface",
                "description": "SDK: `do_navigate()`\n\nNotes:\n<br>... [STB]\n * For specific information about supported `bookmark` and `params` values supported by XAPI, see\n   https://etwiki.sys.comcast.net/pages/viewpage.action?spaceKey=xcalPDEV&title=XAPI+Service++Specification\n   (section 3.7.1 \"navigateto\").\n\n<br>... [SSP]\n * The following `params` items are recognized for generic navigation:\n     type:     (str) Navigation type: 'ID' or 'XPATH' (case-insensitive, default: ID)\n     constant: (bool) \"Look up navigation `bookmark` within SSPC platform-specific constants.\" (else verbatim)\n                      (default: True)\n     click:    (bool) \"Automatically 'click' the navigated item.\" (else just select destination)\n                      (default: True)",
                "operationId": "do_navigate",
                "parameters": [
                    {
                        "name": "bookmark",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Page identifier/location (a.k.a. \"bookmark\") to navigate to"
                    },
                    {
                        "name": "retry",
                        "in": "query",
                        "type": "boolean",
                        "description": "[STB] \"Press EXIT and retry navigation on failure.\"",
                        "default": true
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/play_asset/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "\"Initiation of playback appears to be successful.\"",
                        "schema": {
                            "type": "boolean"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Initiates playback of the asset currently selected",
                "description": "SDK: `do_play_asset()`\n\nNotes:\n * If an asset has not been previously specified by `set_asset()`, begins/resumes playback of the current\n   streaming source in effect for the player, if any.",
                "operationId": "do_play_asset",
                "parameters": [
                    {
                        "name": "resume",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Resume playback of previously stopped asset, if applicable.\" (else start playback anew)",
                        "default": false
                    },
                    {
                        "name": "network",
                        "in": "query",
                        "type": "string",
                        "description": "Network from which playback of asset should originate (e.g., VOD_TVGO)\n                (None => default network)"
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/press_key/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "\"Button press appears to be successful.\"",
                        "schema": {
                            "type": "boolean"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Enters a \"keypress\" into the device UI using whatever control plane is provided for the player device",
                "description": "SDK: `do_press_key()`\n\nNotes:\n<br>... [STB]\n * Uses the XAPI to simulate remote control keypresses via XRE/Linchpin; if available as a device option\n   and if hardware is configured to do so.\n * When using XAPI, the success/fail return value indicates positive feedback from XAPI that the keypress\n   was successfully sent to the STB.\n\n<br>... [SSP]\n * Uses the SSPC driver layer to simulate player control application UI touches/clicks via Appium/Selenium.",
                "operationId": "do_press_key",
                "parameters": [
                    {
                        "name": "button",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Button (key) to press on the \"remote control\" (must be one of known BUTTON definitions)"
                    },
                    {
                        "name": "repeat",
                        "in": "query",
                        "type": "integer",
                        "description": "Repeat count for button press (number of consecutive presses)",
                        "default": 1
                    },
                    {
                        "name": "delay",
                        "in": "query",
                        "type": "number",
                        "description": "Pacing duration (sec) to delay after each button press",
                        "default": 2
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/reboot/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "\"Rebooted successfully.\"  (otherwise, no positive indication of success detected)",
                        "schema": {
                            "type": "boolean"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Interacts with this player device to cause it to reboot itself",
                "description": "SDK: `do_reboot_device()`\n\nNotes:\n * Executes synchronously, not returning until device is (presumably) rebooted.\n\n<br>... [STB]\n * This is not a reliable indicator that the device is reachable via the Jump Server or that the XRE has been\n   connected (if applicable): success does not necessarily mean that the device has connected to the XRE, but\n   typically if the device can be logged into via SSH, then the device can connect to the XRE.\n * When XAPI rebooting is selected, uses the XAPI `check_alive` endpoint to verify the device is back up.",
                "operationId": "do_reboot_device",
                "parameters": [
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Timeout period (sec), within which reboot is expected to complete",
                        "default": 1200
                    },
                    {
                        "name": "use_shell",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Use shell connection to reboot the device and verify is back up and running.\"\n                  (else use XAPI)",
                        "default": true
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/screenshot/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Serialized (base-64) representation of screen frame image ('content'==True) or filespec containing\n         image ('content'==False)",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Captures and returns a snapshot of the current screen frame from the player device control plane",
                "description": "SDK: `get_screenshot()`\n\nNotes:\n * Uses whatever device category-specific facility exists in the control plane for retrieving the frame image.\n * Use `analysis_api.get_screenshot()` to capture the image from the stream capture hardware.\n * See `capture_screenshot()` for the default file specification.\n\n<br>... [STB]\n * Retrieves frame image from the XRE screenshot service.\n\n<br>... [SSP]\n * Retrieves frame image from SSPC.",
                "operationId": "get_screenshot",
                "parameters": [
                    {
                        "name": "filename",
                        "in": "query",
                        "type": "string",
                        "description": "File specification where to store current screen frame captured (None => default capture file)"
                    },
                    {
                        "name": "content",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Return encoded BLOB containing frame content.\"  (else return filespec where content is stored)",
                        "default": false
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/seek/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Moves playback position chronologically to a fixed time in the stream",
                "description": "SDK: `do_seek()`",
                "operationId": "do_seek",
                "parameters": [
                    {
                        "name": "time_offset",
                        "in": "query",
                        "type": "number",
                        "required": true,
                        "description": "Time offset (sec) from start within asset where to continue playback"
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/set_asset/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Specifies the current streaming asset to use for auditing and testing purposes",
                "description": "SDK: `set_asset()`\n\nNotes:\n * An Asset Index is a curated collection of supported streaming assets (e.g., VOD, linear streams,\n   DVR recordings, etc.) usable for testing/auditing purposes here.\n\n<br>... [STB]\n * By default STBs play content streamed from the Comcast production Content Delivery Network (CDN), unless\n   an asset URL is installed in a special configuration file on the STB which \"overrides\" the streaming source\n   to be that specified asset.\n * Asset URLs can override streaming at either of these injection points:\n    * AAMP: adds an override def in the AAMP (Advanced Adaptive Media Player) configuration file on the STB\n    * XRE:  replaces the 'aveOverrideContentURL' field in the XRE configuration file on the STB\n * The `override` parameter specifies an asset URL substring pattern, and when an asset containing that\n   pattern is matched during a \"tuning\" operation, the specified `asset` is tuned to instead.\n * If the `asset` specified is itself overridden on the STB, that override is removed first, before establishing\n    the intended override.\n * The STB receiver component is reset as a side-effect in order to effect the asset override.\n\n\n\n<br>... [STB]\n * Default `asset_index` is \"{DEFAULT_ASSET_INDEX}\".\n\n<br>... [SSP]\n * Default `asset_index` is \"{DEFAULT_ASSET_INDEX}\".",
                "operationId": "set_asset",
                "parameters": [
                    {
                        "name": "asset",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "URL or other identifier for asset to use (depends upon asset_index)\n                       (vacuous => remove override for call_sign)"
                    },
                    {
                        "name": "asset_index",
                        "in": "query",
                        "type": "string",
                        "description": "Asset Index where asset information is stored (unspecified => use default index)"
                    },
                    {
                        "name": "asset_selector",
                        "in": "query",
                        "type": "string",
                        "description": "Asset selector -- items heeded:\n                        * season:           (XS, PP) The number of the season to choose from\n                        * zip_code:         (PP) Simulated location (VSS) for asset playback\n                        * performance:      (PP) \"Asset is a performance.\"\n                        * eas:              (PP) \"EAS enabled.\"\n                        * asset_type:       (STB, XS) Type of asset (Linear, VOD, etc.)\n                        * channel_key:      (XS) Choose asset by some \"key\" to look for (example: \"ep9\")\n                        * channel_collection (XS) Channel collection from which the linear asset is selected\n                                                (expects names such as: Showtime, HBO, HLN, CBS, CNN, etc)\n                        * check_recent:     (XS) Check to see if there is the asset is in the recent list\n                                                 (expects keywords \"TV\" or \"Movie\" for VOD assets)"
                    },
                    {
                        "name": "override",
                        "in": "query",
                        "type": "string",
                        "description": "Asset name fragment to override (linear channel call sign or VOD asset name portion):\n                       to be overridden by `asset` content (None => built-in override default)"
                    },
                    {
                        "name": "access_check",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Check nominal accessibility of manifest URL (from EAPI server).\"",
                        "default": true
                    },
                    {
                        "name": "override_type",
                        "in": "query",
                        "type": "string",
                        "description": "[STB] Asset override type ('AAMP' or 'XRE')",
                        "default": "AAMP"
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/set_controls_mode/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Reveals/hides onscreen \"remote\" controls",
                "description": "SDK: `set_controls_mode()`",
                "operationId": "set_controls_mode",
                "parameters": [
                    {
                        "name": "revealed",
                        "in": "query",
                        "type": "boolean",
                        "required": true,
                        "description": "\"Reveals onscreen controls.\" (else hides controls)"
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/setting/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Value of setting (\"truthy\" settings are retrieved as bool, otherwise value has setting-specific type);\n         None => setting is not retrievable due to design of service",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Returns a particular setting value from this player device",
                "description": "SDK: `get_setting()`\n\nNotes:\n * To reduce the number of external services requests incurred, settings values retrieved by this resource are\n   cached for future retrievals.",
                "operationId": "get_setting",
                "parameters": [
                    {
                        "name": "setting",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name of player device setting to retrieve (case-insensitive) -- see model `DeviceSettings`\n                (not all settings available for all device categories)"
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            },
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Value of setting after assignment (\"truthy\" settings are retrieved as bool, otherwise int or str value)",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Modifies a particular setting on this player device",
                "description": "SDK: `set_setting()`\n\nNotes:\n * To reduce the number of external service requests incurred, settings values assigned by this resource are\n   cached internally for future retrievals.",
                "operationId": "set_setting",
                "parameters": [
                    {
                        "name": "setting",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name of player device setting to retrieve (case-insensitive) -- see model `DeviceSettings`\n                (not all settings available for all device categories)"
                    },
                    {
                        "name": "value",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Value to set for setting (may also be any \"truthy\" bool)"
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/shutdown/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Ceases active stream processing for this device and terminates its worker process",
                "description": "SDK: `do_shutdown()`\n\nNotes:\n * Halts processing operations for the device within the BATS processing abstraction object corresponding\n   to the player device in the BATS Core library, and destroys that object.\n * WARNING: this will typically not return!",
                "operationId": "do_shutdown",
                "parameters": [
                    {
                        "name": "kill",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Kill BATS Core media stream engine explicitly after calling its shutdown() method.\"",
                        "default": false
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/startup/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Spawns the worker process for this device and starts active stream processing",
                "description": "SDK: `do_startup()`\n\nNotes:\n * The BATS processing abstraction object corresponding to the player device in the BATS Core library\n   is instantiated from the worker process, and processing operations for the device within that abstraction\n   are initiated.\n * WARNING! Once instantiated, all use of/interaction with the BATS Core object must occur within the\n   worker process.",
                "operationId": "do_startup",
                "parameters": [
                    {
                        "name": "force",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Forcibly kill existing worker process and spawn a new worker if it was not already shut down.\"",
                        "default": false
                    },
                    {
                        "name": "origin",
                        "in": "query",
                        "type": "string",
                        "description": "Origin for BATS Core stream source -- choices: []",
                        "default": "N/A"
                    },
                    {
                        "name": "audio",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Also include audio in stream processing.\"",
                        "default": true
                    },
                    {
                        "name": "repeat",
                        "in": "query",
                        "type": "boolean",
                        "description": "(heeded for URL streams only) \"Repeat media streaming in continuous loop.\"",
                        "default": false
                    },
                    {
                        "name": "speed",
                        "in": "query",
                        "type": "number",
                        "description": "(heeded for URL streams only) Speed multiplier for playback (- => as fast as possible)",
                        "default": -1
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/tune/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Message from tuning operation",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Changes content source for video/audio stream being played on main screen of device",
                "description": "SDK: `do_tune()`\n\nNotes:\n<br>... [STB]\n * `source_type` is limited to any one of those supported by XAPI/deeplinks (see `source` below)\n * `source` depends upon `source_type`; these sources are recognized:\n      channel:  (int) linear channel number (-1 => most recent channel visited previously)\n      callsign: (str) linear channel callsign\n      VOD:      (str) URL for VOD (format: vod://<providerId><contentId>)\n      DVR:      (str) URL for DVR resource (recording ID)\n      web:      (str) arbitrary web URL\n\n<br>... [SSP]\n * `source_type` and `source` depends upon the asset source from which the current asset is selected;\n   for the purposes of specifying these tuning parameters, see STB conventions.",
                "operationId": "do_tune",
                "parameters": [
                    {
                        "name": "source_type",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Source type for stream content"
                    },
                    {
                        "name": "source",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Specific source for content of `source_type`"
                    },
                    {
                        "name": "retune",
                        "in": "query",
                        "type": "boolean",
                        "description": "[STB] \"(linear only) Perform retuning operation (to IP) in case already tuned to `source`.\" (else skip)",
                        "default": true
                    },
                    {
                        "name": "wait",
                        "in": "query",
                        "type": "boolean",
                        "description": "[STB] \"Wait for/validate response from tuning operation.\"",
                        "default": true
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/device/watch_playback/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Navigates to active TV watching of the video/audio stream",
                "description": "SDK: `do_watch_playback()`\n\nNotes:\n<br>... [STB]\n * Entering \"fullscreen\" mode on an STB entails immediately exiting from all menus/submenus and/or dialogs.\n * Wakes the STB from sleep mode if applicable.",
                "operationId": "do_watch_playback",
                "parameters": [
                    {
                        "name": "fullscreen",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Switch viewing to fullscreen mode, if applicable/possible.\" (else to windowed mode)",
                        "default": true
                    }
                ],
                "security": [],
                "tags": [
                    "device"
                ]
            }
        },
        "/manager/authorize": {
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "\"Credentials are valid.\"",
                        "schema": {
                            "type": "boolean"
                        }
                    },
                    "HTTPStatus.UNAUTHORIZED": {
                        "description": "Authentication failure"
                    }
                },
                "summary": "Provide username and password/token credentials for resources requiring authorization",
                "description": "SDK: `do_authorize()`\n\nNotes:\n * This resource is provided for SDK use only; from the Swagger GUI, use the [Authorize] button above instead.",
                "operationId": "do_authorize",
                "parameters": [
                    {
                        "name": "username",
                        "in": "query",
                        "type": "string",
                        "description": "Username for authorization request\n                 (None => use Authorization header, or validate using service password only or bearer token)"
                    },
                    {
                        "name": "password",
                        "in": "formData",
                        "type": "string",
                        "format": "password",
                        "description": "Plaintext or base64-encoded password (for `username` if supplied)",
                        "default": ""
                    },
                    {
                        "name": "token",
                        "in": "query",
                        "type": "string",
                        "description": "Token to use for future API requests requiring authorization\n                 (None => use Authorization header, or validate using Basic auth)"
                    },
                    {
                        "in": "header",
                        "description": "HTTP-standard authorization header containing valid Bearer token or Basic credentials",
                        "name": "X-Authorization",
                        "type": "string"
                    }
                ],
                "security": [
                    {
                        "basic": []
                    },
                    {
                        "apikey": []
                    }
                ],
                "consumes": [
                    "application/x-www-form-urlencoded",
                    "multipart/form-data"
                ],
                "tags": [
                    "manager"
                ]
            }
        },
        "/manager/device/define": {
            "post": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/DeviceDefinition"
                        }
                    },
                    "HTTPStatus.PARTIAL_CONTENT": {
                        "description": "Device definition for player device created, but with warnings",
                        "schema": {
                            "$ref": "#/definitions/DeviceDefinition"
                        }
                    },
                    "HTTPStatus.CONFLICT": {
                        "description": "Player device definition already exists at slot"
                    },
                    "HTTPStatus.BAD_REQUEST": {
                        "description": "Invalid player device definition parameters"
                    },
                    "HTTPStatus.UNPROCESSABLE_ENTITY": {
                        "description": "Device definition failure"
                    }
                },
                "summary": "Registers a definition for a player device or virtual player device at a particular \"slot ID\", optionally         creating an entry within the player device registry (unless it is a \"temporary\" device)",
                "description": "SDK: `do_device_define()`\n\nNotes:\n * A \"temporary\" player device is one for which `slot_id` is unspecified or empty; these are automatically\n   assigned an arbitrarily generated slot ID \"temp...\".",
                "operationId": "do_device_define",
                "parameters": [
                    {
                        "name": "payload",
                        "required": true,
                        "in": "body",
                        "schema": {
                            "$ref": "#/definitions/DeviceDefinition"
                        }
                    }
                ],
                "security": [],
                "tags": [
                    "manager/device"
                ]
            }
        },
        "/manager/device/discover": {
            "get": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/DeviceDefinition"
                            }
                        }
                    },
                    "HTTPStatus.UNPROCESSABLE_ENTITY": {
                        "description": "Device discovery failure"
                    }
                },
                "summary": "Discovers player devices defined as accessible through this EAPI server, and their characteristics, for this         requestor",
                "description": "SDK: `get_devices_discover()`",
                "operationId": "get_devices_discover",
                "parameters": [
                    {
                        "name": "slot_id",
                        "in": "query",
                        "type": "string",
                        "description": "Slot ID for device for which to retrieve static device definition (None => not limited to slot)"
                    },
                    {
                        "name": "devtype",
                        "in": "query",
                        "type": "string",
                        "description": "Only discover devices of make/model/version (None => not limited to device type)"
                    }
                ],
                "security": [],
                "tags": [
                    "manager/device"
                ]
            }
        },
        "/manager/device/rediscover": {
            "post": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/DeviceDefinition"
                            }
                        }
                    },
                    "HTTPStatus.UNPROCESSABLE_ENTITY": {
                        "description": "Device (re)definition/discovery failure"
                    }
                },
                "summary": "Redefines player devices as defined within the default device registry for this requestor, and discovers their         characteristics",
                "description": "SDK: `do_devices_rediscover()`",
                "operationId": "do_devices_rediscover",
                "security": [],
                "tags": [
                    "manager/device"
                ]
            }
        },
        "/manager/device/release/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Unknown player device"
                    }
                },
                "summary": "Relinquishes exclusive use of the specified player device by the requestor, and makes it available again for         reservation",
                "description": "SDK: `do_device_release()`",
                "operationId": "do_device_release",
                "parameters": [
                    {
                        "name": "temp",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Release temporary reservation.\"",
                        "default": false
                    },
                    {
                        "name": "cleanup",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Close any BATS Core device worker and exit any open device session before releasing.\"",
                        "default": true
                    }
                ],
                "security": [],
                "tags": [
                    "manager/device"
                ]
            }
        },
        "/manager/device/reserve/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Client ID for holder of device reservation (None => device is unreserved)",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Device is unreserved"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Unknown player device"
                    }
                },
                "summary": "Determines which client, if any, currently holds the reservation for a player device",
                "description": "SDK: `get_device_reserve()`",
                "operationId": "get_device_reserve",
                "security": [],
                "tags": [
                    "manager/device"
                ]
            },
            "post": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/DeviceDefinition"
                        }
                    },
                    "HTTPStatus.CONFLICT": {
                        "description": "Player device is already reserved by another client"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Unknown player device"
                    }
                },
                "summary": "Reserves the specified player device for exclusive use by the requestor",
                "description": "SDK: `do_device_reserve()`",
                "operationId": "do_device_reserve",
                "parameters": [
                    {
                        "name": "strict",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Only reserve an unreserved device, even if requestor already holds reservation.\"",
                        "default": false
                    },
                    {
                        "name": "force",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Forcibly usurp reservation for device if already reserved, and grant reservation to requestor.\"\n                (deprecated)",
                        "default": false
                    },
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Inactivity timeout (sec): time interval after which, if there have been no API requests\n                for the device, the reservation is automatically released and future API requests\n                (not including the one in progress, if any) are denied\n                (None/0 => persistent reservation: no auto-release)",
                        "default": 0
                    }
                ],
                "security": [],
                "tags": [
                    "manager/device"
                ]
            }
        },
        "/manager/device/reserve_any": {
            "post": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/DeviceDefinition"
                        }
                    },
                    "HTTPStatus.CONFLICT": {
                        "description": "Player device is already reserved by another client"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Unknown player device"
                    }
                },
                "summary": "Reserves the first unreserved player device of the specified device type for exclusive use by the requestor",
                "description": "SDK: `do_device_reserve_any()`",
                "operationId": "do_device_reserve_any",
                "parameters": [
                    {
                        "name": "devtype",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Device make/model/version of device to reserve"
                    },
                    {
                        "name": "force",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Forcibly usurp reservation for device when already reserved.\"",
                        "default": false
                    }
                ],
                "security": [],
                "tags": [
                    "manager/device"
                ]
            }
        },
        "/manager/device/service_status/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/DeviceServiceStatus"
                        }
                    },
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Device is unreserved"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Unknown player device"
                    }
                },
                "summary": "Retrieves information about the current status of processing within this service for this device",
                "description": "SDK: `get_service_status()`",
                "operationId": "get_service_status",
                "security": [],
                "tags": [
                    "manager/device"
                ]
            }
        },
        "/manager/device/set_log_verbosity/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Previous log level/sublevel for device",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "HTTPStatus.FORBIDDEN": {
                        "description": "Player device not initialized by requestor"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Unknown player device"
                    }
                },
                "summary": "Dynamically controls the current logging level/sublevel for a player device",
                "description": "SDK: `set_log_verbosity()`",
                "operationId": "set_log_verbosity",
                "parameters": [
                    {
                        "name": "log_level",
                        "in": "query",
                        "type": "string",
                        "description": "Logging verbosity level for device: standard Python `logger` level (DEBUG, INFO, ...)\n                     (None => do not affect)"
                    },
                    {
                        "name": "log_sublevel",
                        "in": "query",
                        "type": "string",
                        "description": "Specifier (string or number) specifying log sublevel (None => not specified, do not affect)"
                    }
                ],
                "security": [],
                "tags": [
                    "manager/device"
                ]
            }
        },
        "/manager/device/set_registry": {
            "post": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/DeviceDefinition"
                            }
                        }
                    },
                    "HTTPStatus.UNPROCESSABLE_ENTITY": {
                        "description": "Device registry (un)definition failure"
                    }
                },
                "summary": "Establishes the player device registry to use to find and refer to device slot IDs, or reverts to using the         default (pre-provisioned) registry, for all subsequent device-related API requests from this BATS client",
                "description": "SDK: `do_device_set_registry()`\n\nNotes:\n * This registry override remains in effect only while this EAPI server remains executing;\n   this is not persistent.",
                "operationId": "do_device_set_registry",
                "parameters": [
                    {
                        "name": "registry",
                        "in": "formData",
                        "type": "string",
                        "description": "Server-side directory containing alternate device registry, or (JSON/YAML) registry content\n                 (None => revert to using pre-provisioned registry)"
                    },
                    {
                        "name": "title",
                        "in": "formData",
                        "type": "string",
                        "description": "Title to label registry"
                    }
                ],
                "security": [],
                "consumes": [
                    "application/x-www-form-urlencoded",
                    "multipart/form-data"
                ],
                "tags": [
                    "manager/device"
                ]
            }
        },
        "/manager/device/undefine/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.UNPROCESSABLE_ENTITY": {
                        "description": "Device removal failure"
                    }
                },
                "summary": "Undefines a player device from the device roster, removing it from the device registry unless it is a         hard-configured player device",
                "description": "SDK: `do_device_undefine()`\n\nNotes:\n * \"Hard-configured\" means any device corresponding to an attached HDMI video/audio channel on the server.",
                "operationId": "do_device_undefine",
                "security": [],
                "tags": [
                    "manager/device"
                ]
            }
        },
        "/manager/quality_services_start": {
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.UNAUTHORIZED": {
                        "description": "Restart disallowed"
                    },
                    "HTTPStatus.METHOD_NOT_ALLOWED": {
                        "description": "No quality services available"
                    },
                    "HTTPStatus.UNPROCESSABLE_ENTITY": {
                        "description": "Failure (re)starting services"
                    }
                },
                "summary": "(Re)starts the `quality` services for all player devices attached to this BATS server",
                "description": "SDK: `do_quality_services_start()`\n\nNotes:\n * At this time, quality services are provided by SSIMWAVE; this starts all licensed and configured SSIMWAVE\n   LiveMonitor services installed on this BATS server.",
                "operationId": "do_quality_services_start",
                "parameters": [
                    {
                        "name": "restart",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Restart quality services.\" (else start it initially)",
                        "default": false
                    },
                    {
                        "in": "header",
                        "description": "HTTP-standard authorization header containing valid Bearer token or Basic credentials",
                        "name": "X-Authorization",
                        "type": "string"
                    }
                ],
                "security": [
                    {
                        "basic": []
                    },
                    {
                        "apikey": []
                    }
                ],
                "tags": [
                    "manager"
                ]
            }
        },
        "/manager/quality_services_stop": {
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.UNAUTHORIZED": {
                        "description": "Restart disallowed"
                    },
                    "HTTPStatus.METHOD_NOT_ALLOWED": {
                        "description": "No quality services available"
                    },
                    "HTTPStatus.UNPROCESSABLE_ENTITY": {
                        "description": "Failure stopping services"
                    }
                },
                "summary": "Stops the `quality` services for all player devices attached to this BATS server",
                "description": "SDK: `do_quality_services_stop()`\n\nNotes:\n * At this time, quality services are provided by SSIMWAVE; this stops all licensed and configured SSIMWAVE\n   LiveMonitor services installed on this BATS server.",
                "operationId": "do_quality_services_stop",
                "parameters": [
                    {
                        "in": "header",
                        "description": "HTTP-standard authorization header containing valid Bearer token or Basic credentials",
                        "name": "X-Authorization",
                        "type": "string"
                    }
                ],
                "security": [
                    {
                        "basic": []
                    },
                    {
                        "apikey": []
                    }
                ],
                "tags": [
                    "manager"
                ]
            }
        },
        "/manager/server_info": {
            "get": {
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/ServerInformation"
                        }
                    }
                },
                "summary": "Retrieves information about this EAPI service, BATS Core, and BATS server platform",
                "description": "SDK: `get_server_info()`",
                "operationId": "get_server_info",
                "security": [],
                "tags": [
                    "manager"
                ]
            }
        },
        "/manager/service_restart": {
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.GONE": {
                        "description": "Success"
                    },
                    "HTTPStatus.GATEWAY_TIMEOUT": {
                        "description": "Success"
                    },
                    "HTTPStatus.UNAUTHORIZED": {
                        "description": "Restart disallowed"
                    },
                    "HTTPStatus.UNPROCESSABLE_ENTITY": {
                        "description": "Failure restarting service"
                    }
                },
                "summary": "Restarts this EAPI service instance",
                "description": "SDK: `do_service_restart()`\n\nNotes:\n * This will dissolve any existing connection sessions executing on this server, causing testing/auditing\n   operations in progress to fail, possibly unrecoverably.\n * For a production instance, this request will result in a 504 GATEWAY TIMEOUT status in case of a *successful*\n   service restart.\n * For a development instance, this request will result in a 410 GONE status and will shut down the service;\n   the EAPI service must then be restarted manually.",
                "operationId": "do_service_restart",
                "parameters": [
                    {
                        "in": "header",
                        "description": "HTTP-standard authorization header containing valid Bearer token or Basic credentials",
                        "name": "X-Authorization",
                        "type": "string"
                    }
                ],
                "security": [
                    {
                        "basic": []
                    },
                    {
                        "apikey": []
                    }
                ],
                "tags": [
                    "manager"
                ]
            }
        },
        "/manager/service_stop": {
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.GONE": {
                        "description": "Success"
                    },
                    "HTTPStatus.GATEWAY_TIMEOUT": {
                        "description": "Success"
                    },
                    "HTTPStatus.UNAUTHORIZED": {
                        "description": "Stop disallowed"
                    },
                    "HTTPStatus.UNPROCESSABLE_ENTITY": {
                        "description": "Failure stopping service"
                    }
                },
                "summary": "Stops this EAPI service instance",
                "description": "SDK: `do_service_stop()`\n\nNotes:\n * This will dissolve any existing connection sessions executing on this server, causing testing/auditing\n   operations in progress to fail, possibly unrecoverably.\n * For a production instance, this request will result in a 504 GATEWAY TIMEOUT status in case of a *successful*\n   service stoppage.\n * For a development instance, this request will result in a 410 GONE status and will shut down the service.",
                "operationId": "do_service_stop",
                "parameters": [
                    {
                        "in": "header",
                        "description": "HTTP-standard authorization header containing valid Bearer token or Basic credentials",
                        "name": "X-Authorization",
                        "type": "string"
                    }
                ],
                "security": [
                    {
                        "basic": []
                    },
                    {
                        "apikey": []
                    }
                ],
                "tags": [
                    "manager"
                ]
            }
        },
        "/manager/set_log_verbosity": {
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Previous log level",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.UNAUTHORIZED": {
                        "description": "Change disallowed"
                    }
                },
                "summary": "Dynamically controls the current logging level",
                "description": "SDK: `set_log_verbosity()`",
                "operationId": "set_log_verbosity",
                "parameters": [
                    {
                        "name": "log_level",
                        "in": "query",
                        "type": "string",
                        "description": "Logging verbosity level to set: standard Python `logger` level (DEBUG, INFO, ...)\n                  (None => do not affect)"
                    },
                    {
                        "in": "header",
                        "description": "HTTP-standard authorization header containing valid Bearer token or Basic credentials",
                        "name": "X-Authorization",
                        "type": "string"
                    }
                ],
                "security": [
                    {
                        "basic": []
                    },
                    {
                        "apikey": []
                    }
                ],
                "tags": [
                    "manager"
                ]
            }
        },
        "/manager/streaming_start": {
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.UNAUTHORIZED": {
                        "description": "Restart disallowed"
                    },
                    "HTTPStatus.METHOD_NOT_ALLOWED": {
                        "description": "No streaming service available"
                    },
                    "HTTPStatus.UNPROCESSABLE_ENTITY": {
                        "description": "Failure (re)starting service"
                    }
                },
                "summary": "(Re)starts the BATS streaming service for all player devices attached to this BATS server",
                "description": "SDK: `do_streaming_start()`",
                "operationId": "do_streaming_start",
                "parameters": [
                    {
                        "name": "restart",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Restart streaming service.\" (else start it initially)",
                        "default": false
                    },
                    {
                        "in": "header",
                        "description": "HTTP-standard authorization header containing valid Bearer token or Basic credentials",
                        "name": "X-Authorization",
                        "type": "string"
                    }
                ],
                "security": [
                    {
                        "basic": []
                    },
                    {
                        "apikey": []
                    }
                ],
                "tags": [
                    "manager"
                ]
            }
        },
        "/manager/streaming_stop": {
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.UNAUTHORIZED": {
                        "description": "Stop disallowed"
                    },
                    "HTTPStatus.METHOD_NOT_ALLOWED": {
                        "description": "No streaming service available"
                    },
                    "HTTPStatus.UNPROCESSABLE_ENTITY": {
                        "description": "Failure stopping service"
                    }
                },
                "summary": "Stops the BATS streaming service for all player devices attached to this BATS server",
                "description": "SDK: `do_streaming_stop()`",
                "operationId": "do_streaming_stop",
                "parameters": [
                    {
                        "in": "header",
                        "description": "HTTP-standard authorization header containing valid Bearer token or Basic credentials",
                        "name": "X-Authorization",
                        "type": "string"
                    }
                ],
                "security": [
                    {
                        "basic": []
                    },
                    {
                        "apikey": []
                    }
                ],
                "tags": [
                    "manager"
                ]
            }
        },
        "/manager/web_gui_restart": {
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.UNAUTHORIZED": {
                        "description": "Restart disallowed"
                    },
                    "HTTPStatus.METHOD_NOT_ALLOWED": {
                        "description": "No WebGUI service available"
                    },
                    "HTTPStatus.UNPROCESSABLE_ENTITY": {
                        "description": "Failure (re)starting service"
                    }
                },
                "summary": "Restarts the BATS WebGUI services for all player devices attached to this BATS server",
                "description": "SDK: `do_web_gui_restart()`",
                "operationId": "do_web_gui_restart",
                "parameters": [
                    {
                        "in": "header",
                        "description": "HTTP-standard authorization header containing valid Bearer token or Basic credentials",
                        "name": "X-Authorization",
                        "type": "string"
                    }
                ],
                "security": [
                    {
                        "basic": []
                    },
                    {
                        "apikey": []
                    }
                ],
                "tags": [
                    "manager"
                ]
            }
        },
        "/outcome/artifacts/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Serialized (base-64) representation of encoded BLOB (`content`==True) or server-side filespec where\n         BLOB is stored (`content`==False)",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves all artifacts from the device and server that have been accumulated as side-effects or outcomes         of testing",
                "description": "SDK: `get_artifacts()`",
                "operationId": "get_artifacts",
                "parameters": [
                    {
                        "name": "content",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Return encoded BLOB result.\"  (else return filespecs where content is stored)",
                        "default": false
                    },
                    {
                        "name": "maxsize",
                        "in": "query",
                        "type": "integer",
                        "description": "Maximum size for each artifact file (None => no limit)"
                    }
                ],
                "security": [],
                "tags": [
                    "outcome"
                ]
            }
        },
        "/outcome/collect_logs/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Result pair:\n          [0] Server-side filespec where BLOB is stored\n          [1] Serialized (base-64) representation of encoded BLOB ('content'==True); empty for `content`==False",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves a device category-specific collection of logs from the player device, stores them on the server         filesystem, and optionally retrieves their content as a BLOB",
                "description": "SDK: `get_logs()`\n\nNotes:\n * May be size-limited by HTTP-based transmission interface when retrieving log content; recommended to use\n   'file_upload' for large files instead.",
                "operationId": "get_logs",
                "parameters": [
                    {
                        "name": "filespec",
                        "in": "query",
                        "type": "string",
                        "description": "File specification for a file on the player device filesystem where the logs are stored\n                 (None => retrieve a canonical set of logs specific to the device category)"
                    },
                    {
                        "name": "content",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Return BLOB containing collected log content.\"\n                 (else return server filespec where content is stored)",
                        "default": true
                    },
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Timeout period (sec) allowed for log retrieval from STB (None => unlimited duration)"
                    }
                ],
                "security": [],
                "tags": [
                    "outcome"
                ]
            }
        },
        "/outcome/recording/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Serialized (base-64) representation of encoded BLOB ('content'==True) or server-side filespec where\n         BLOB is stored ('content'==False)",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves the named stream recording captured from this player device",
                "description": "SDK: `get_recording()`\n\nNotes:\n * Recording name must exist on this device, or an exception will be generated.\n * This method will stop any recording that might currently be being captured.\n * Use :method:`collect_recording_names()` to retrieve the list of captured recordings available\n   on this player device.",
                "operationId": "get_recording",
                "parameters": [
                    {
                        "name": "recording",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name of recording to retrieve"
                    },
                    {
                        "name": "content",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Return encoded BLOB result.\"  (else return filespec where content is stored)",
                        "default": false
                    }
                ],
                "security": [],
                "tags": [
                    "outcome"
                ]
            }
        },
        "/outcome/recording_names/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Recordings available",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves the list of all stream recording names captured from this player device and available for retrieval",
                "description": "SDK: `get_recording_names()`",
                "operationId": "get_recording_names",
                "security": [],
                "tags": [
                    "outcome"
                ]
            }
        },
        "/outcome/screenshots/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Result pair:\n          [0] Server-side filespec where BLOB is stored\n          [1] Serialized (base-64) representation of encoded BLOB ('content'==True); empty for `content`==False",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves all frame screenshots captured from this player device, arranged in a mosaic",
                "description": "SDK: `get_screenshots()`\n\nNotes:\n * May be size-limited by HTTP-based transmission interface.",
                "operationId": "get_screenshots",
                "parameters": [
                    {
                        "name": "content",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Return encoded BLOB result.\"  (else return filespec where content is stored)",
                        "default": false
                    }
                ],
                "security": [],
                "tags": [
                    "outcome"
                ]
            }
        },
        "/outcome/send_results_to_octane/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "URL of where verdict was uploaded",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Consumes canonical auditing/testing outcome artifacts and uploads these results to Octane",
                "description": "SDK: `do_send_results_to_octane()`\n\nNotes:\n * `verdict` and each `step_verdicts` element are interpreted as follows:\n     - any truthy value => success as per Octane Test Design\n     - \"Incomplete\" =>     (case-insensitive) outcome could not be determined due to infrastructure\n                                              insufficiency or testing preconditions being unmet\n                                              (translated to \"Skipped\" in Octane)\n     - \"Unexecuted\" =>     (case-insensitive) outcome could not be determined because it is inapplicable\n                                              to the test run\n                                              (translated to \"Planned\" in Octane)\n     - otherwise =>        failure",
                "operationId": "do_send_results_to_octane",
                "parameters": [
                    {
                        "name": "test_suite",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name of the Test Suite to which this test case belongs"
                    },
                    {
                        "name": "test_case_name",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name string or numeric ID (e.g., from \"TC-xxx\") of the Octane Test Case\n                          to upload verdict for"
                    },
                    {
                        "name": "verdict",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Test case execution verdict:\n                            * any truthy value => success as per test case design specification\n                            * \"incomplete\" =>     outcome could not be determined due to infrastructure\n                                                  insufficiency or test case preconditions being unmet\n                            * otherwise =>        failure"
                    },
                    {
                        "name": "system_version",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "System version that was tested against, generated by System Version Generator"
                    },
                    {
                        "name": "system_components",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Components that constitute the system under test"
                    },
                    {
                        "name": "results",
                        "in": "formData",
                        "type": "string",
                        "required": true,
                        "description": "JSON-ifiable results that can be consumed by Octane (str => serialized JSON)\n                          ('@'-prefixed str => file specification for file to read results from)"
                    },
                    {
                        "name": "release_structure",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Folder hierarchy within which to upload results ('/'-separated \"path\");\n                          metavariables substituted in folder names:\n                             $system_version  - specified `system_version`\n                             $fw_version      - firmware version (STB => RDK)\n                             $device_category - device category (e.g., STB or SSP)\n                             $device_type     - device type (make/model)\n                             $device_platform - device platform (not defined => $device_type)\n                             $device_partner  - syndication partner for device\n                             $device_slot     - server slot id for device\n                             $asset_type      - MPEG-4 type (DASH/HLS)\n                             $asset_name      - asset name\n                             $timestamp       - formatted test start time\n                             $YYYY            -   \" year\n                             $MM              -   \" month\n                             $DD              -   \" day\n                             $hh              -   \" hour\n                             $mm              -   \" minute\n                             $ss              -   \" second"
                    },
                    {
                        "name": "fw_version",
                        "in": "query",
                        "type": "string",
                        "description": "Firmware version for player device under test (None => unknown)"
                    },
                    {
                        "name": "asset",
                        "in": "query",
                        "type": "string",
                        "description": "URL or other identifier for the asset used during the test (if any)",
                        "default": ""
                    },
                    {
                        "name": "collect_artifacts",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Collect test artifacts.\"",
                        "default": true
                    },
                    {
                        "name": "message",
                        "in": "query",
                        "type": "string",
                        "description": "Commentary about the testing verdict (None => no comment)"
                    },
                    {
                        "name": "octane_url",
                        "in": "query",
                        "type": "string",
                        "description": "URL for Octane API server (default: VIPER Octane host)",
                        "default": "https://almoctane-ams.saas.microfocus.com"
                    },
                    {
                        "name": "client_id",
                        "in": "query",
                        "type": "string",
                        "description": "Octane API client ID token for EA (None => default EA client)"
                    },
                    {
                        "name": "client_secret",
                        "in": "query",
                        "type": "string",
                        "description": "Octane API client secret for EA (None => read from Vault)"
                    },
                    {
                        "name": "sharedspace",
                        "in": "query",
                        "type": "string",
                        "description": "Octane shared space name (None => EA default)"
                    },
                    {
                        "name": "workspace",
                        "in": "query",
                        "type": "string",
                        "description": "Octane workspace name (None => EA default)"
                    },
                    {
                        "name": "package_name",
                        "in": "query",
                        "type": "string",
                        "description": "Testing \"package\" name (None => EA default)"
                    },
                    {
                        "name": "module_name",
                        "in": "query",
                        "type": "string",
                        "description": "Testing \"module\" name (None => EA default)"
                    },
                    {
                        "name": "class_name",
                        "in": "query",
                        "type": "string",
                        "description": "Testing \"class\" name (None => EA default)"
                    },
                    {
                        "name": "release_name",
                        "in": "query",
                        "type": "string",
                        "description": "Name of a \"release\" for which to upload results (None => `system_version`)"
                    },
                    {
                        "name": "step_verdicts",
                        "in": "query",
                        "type": "string",
                        "description": "Verdicts for all individual Test Step Items defined for this `test_case_name`:\n                          see Notes for valid values (None => set all to same as `verdict`)"
                    }
                ],
                "security": [],
                "consumes": [
                    "application/x-www-form-urlencoded",
                    "multipart/form-data"
                ],
                "tags": [
                    "outcome"
                ]
            }
        },
        "/outcome/test_logs/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Result pair:\n          [0] Server-side filespec where BLOB is stored\n          [1] Serialized (base-64) representation of encoded BLOB ('content'==True); empty for `content`==False",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves device logs from this player device and stores them on the server filesystem",
                "description": "SDK: `get_test_logs()`\n\nNotes:\n * This generic implementation only includes the EAPI Service log for the device.\n * May be size-limited by HTTP-based transmission interface.",
                "operationId": "get_test_logs",
                "parameters": [
                    {
                        "name": "content",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Return encoded BLOB result.\"  (else return filespec where content is stored)",
                        "default": false
                    }
                ],
                "security": [],
                "tags": [
                    "outcome"
                ]
            }
        },
        "/quality/configure_av_probe/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Stream names created for each profile and/or transcoder; usable subsequently to query A/V Sync data",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Configures an A/V probe at the content packager or transcoder or DUT's HDMI to start A/V Sync calculations",
                "description": "SDK: `do_configure_av_probe()`\n\nNotes:\n * For transcoder probes, specify `transcoder_config`.\n * For HDMI probes do not specify any parameters as only the HDMI probe for the DUT can be configured and the\n   configuration will be dynamically determined.\n * Doing both packager and transcoder simultaneously is not supported.\n * Comparing HDMI to HDMI is not supported at this time.\n * Once probes are created, it may take up to two minutes for A/V Sync data to become available (assuming the\n   various probes that have been configured actually are in sync).",
                "operationId": "do_configure_av_probe",
                "parameters": [
                    {
                        "name": "transcoder_config",
                        "in": "query",
                        "type": "string",
                        "description": "Dictionary specifying transcoder configuration --\n                           For transcoder input:\n                            - multicast_address: primary source address\n                            - port: primary source port\n                            - ssm_ip: multicast source IP address\n                           (e.g. dict(multicast_address=\"232.39.212.212\", port=21271, ssm_ip=\"10.44.241.70\"))\n                           For transcoder output:\n                            - multicast_address: destination address\n                            - port: destination port\n                            - ssm_ip: output source address\n                           (e.g. dict(multicast_address=\"236.32.247.94\", port=32000, ssm_ip=\"10.131.159.25\"))"
                    }
                ],
                "security": [],
                "tags": [
                    "quality"
                ]
            }
        },
        "/quality/pull_look_data/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Field data from look, as a list of dictionaries: keys are data field names and values are field values",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves all of the data for a look ID, as defined via the Insights Portal UI",
                "description": "SDK: `get_pull_look_data()`",
                "operationId": "get_pull_look_data",
                "parameters": [
                    {
                        "name": "look_id",
                        "in": "query",
                        "type": "integer",
                        "required": true,
                        "description": "Look ID corresponding to an existing look"
                    }
                ],
                "security": [],
                "tags": [
                    "quality"
                ]
            }
        },
        "/quality/quality_metrics/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "All data from the query",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves SSIMWAVE quality metrics for a service that has this DUT's service name, for a specific time window",
                "description": "SDK: `get_quality_metrics()`\n\nNotes:\n * All A/V Sync metrics only exist once an av_probe is configured using the 'configure_av_probe' endpoint.\n * Separate calls to this endpoint are required for various A/V comparisons.\n * Audio and video are considered out-of-sync by humans when audio is ahead of/behind video by: -125ms/+45ms.\n * Lip-sync problems are considered noticeable at around +/-22ms\n   (see https://en.wikipedia.org/wiki/Audio-to-video_synchronization#Recommendations).",
                "operationId": "get_quality_metrics",
                "parameters": [
                    {
                        "name": "fields",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "List of the various quality metric fields that are to be retrieved for this device.\n                     Each field specified will be included into the response data, if available. SSIMWAVE\n                     aggregates data into one minute samples and so most metrics have min/max/avg.\n                     Fields can include:\n                     - 'avg_qod_score'                 : Average Quality-of-Delivery score\n                     - 'max_qod_score'                 : Maximum Quality-of-Delivery score\n                     - 'min_qod_score'                 : Minimum Quality-of-Delivery score\n                     - 'ssimplus_viewer_score'         : SSIMPLUS subject viewer score calculated\n                                                         (non-referential ML-based score)\n                     - 'avg_ssimplus_viewer_score'     : Average SSIMPLUS viewer score calculated\n                     - 'min_ssimplus_viewer_score'     : Minimum SSIMPLUS viewer score calculated\n                     - 'avg_short_term_loudness_energy': Average audio levels\n                     - 'max_true_peak'                 : Maximum audio level\n                     - 'min_true_peak'                 : Minimum audio level\n                     - 'sum_macroblocking_frame_count' : Total number of frames in which macroblocking was\n                                                         detected\n                     - 'max_macro_blocking_frame_count': Maximum number of frames within each of the 60\n                                                         one-second samples in which macroblocking was detected\n                     - 'percent_macroblocking'         : Percentage of frames in which macroblocking was\n                                                         detected\n                     - 'min_video_latency'             : Minimum time difference between when a sequence\n                                                         of video frames was seen at `av_reference` vs.\n                                                         when it was seen at `av_test`\n                     - 'max_video_latency'             : Maximum time difference between when a sequence\n                                                         of video frames was seen at `av_reference` vs.\n                                                         when it was seen at `av_test`\n                     - 'avg_video_latency'             : Average time difference between when a sequence\n                                                         of video frames was seen at `av_reference` vs.\n                                                         when it was seen at `av_test`\n                     - 'min_audio_latency'             : Minimum time difference between when a sequence\n                                                         of audio frames was heard at `av_reference` vs.\n                                                         when it was seen at `av_test`\n                     - 'max_audio_latency'             : Minimum time difference between when a sequence\n                                                         audio frames was heard at `av_reference` vs.\n                                                         when it was seen at `av_test`\n                     - 'avg_audio_latency'             : Minimum time difference between when a sequence\n                                                         audio frames was heard at `av_reference` vs.\n                                                         when it was seen at `av_test`\n                     - 'min_audio_offset'              : Minimum difference between video latency and audio\n                                                         latency\n                     - 'max_audio_offset'              : Maximum difference between video latency and audio\n                                                         latency\n                     - 'is_aligned'                    : \"SSIMWAVE regards the two sources as mutually aligned.\"\n                                                         (Yes/No string)"
                    },
                    {
                        "name": "start_time",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Start time for the time window from which to gather data in UTC, specifiable in ISO8601\n                     or human-readable formats\n                     (e.g. '2021-06-10T22:56:58.333920', '2021-06-10 22:56:58', '2021-06-10T22:56:58 UTC')"
                    },
                    {
                        "name": "end_time",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "End time for the time window from which to gather data in UTC, specifiable in ISO8601\n                     or human-readable formats\n                     (e.g. '2021-06-10T22:56:58.333920', '2021-06-10 22:56:58', '2021-06-10T22:56:58 UTC')"
                    },
                    {
                        "name": "av_reference",
                        "in": "query",
                        "type": "string",
                        "description": "Stream considered as the source of truth for A/V sync calculations;\n                     The stream name is what is returned when configuring a probe"
                    },
                    {
                        "name": "av_test",
                        "in": "query",
                        "type": "string",
                        "description": "Stream considered as the thing to compare for A/V sync calculations.\n                     The stream name is what is returned when configuring a probe"
                    }
                ],
                "security": [],
                "tags": [
                    "quality"
                ]
            }
        },
        "/quality/signal_metrics/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "A/V quality metrics",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves all audio/video signal quality metrics recorded by SSIMWAVE for this DUT",
                "description": "SDK: `get_signal_metrics()`",
                "operationId": "get_signal_metrics",
                "security": [],
                "tags": [
                    "quality"
                ]
            }
        },
        "/roi/add_ocr_roi/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Adds an Optical Character Recognition (OCR) Region-Of-Interest (ROI) definition to the collection of ROIs         currently being detected by BATS in the device video stream",
                "description": "SDK: `do_add_ocr_roi()`\n\nNotes:\n * @@@@ deprecated: 'roi_api/add_roi' will function for OCR ROIs as well, rendering this method redundant.\n * The ROI name specified by `roi_name` is presumed to be present in the current ROI definitions file.\n * The ROI specified to this method is matched textually after OCR extraction on the ROI; use `add_roi()`\n   to specify an ROI to be matched using image comparison.\n * Once added, ROI matching for the specified ROI ensues immediately; use `match_rois()` to check if an ROI\n   has been matched in the current video stream.\n * CAUTION: Each ROI added to the collection imposes a significant incremental processing burden on BATS;\n   limit the collection of ROIs being detected concurrently to a manageable set.",
                "operationId": "do_add_ocr_roi",
                "parameters": [
                    {
                        "name": "roi_name",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name of OCR ROI definition to begin matching by OCR text"
                    }
                ],
                "security": [],
                "tags": [
                    "roi"
                ]
            }
        },
        "/roi/add_roi/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Adds a Region-Of-Interest (ROI) definition to the collection of ROIs currently being detected by BATS in the         device video stream",
                "description": "SDK: `do_add_roi()`\n\nNotes:\n * The ROI name specified by `roi_name` is presumed to be present in the current ROI definitions file.\n * Once added, ROI matching for the specified ROI ensues immediately; use `match_rois()` to check if an ROI\n   has been matched in the current video stream.\n * CAUTION: Each ROI added to the collection imposes a significant incremental processing burden on BATS;\n   limit the collection of ROIs being detected concurrently to a manageable set.",
                "operationId": "do_add_roi",
                "parameters": [
                    {
                        "name": "roi_name",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name of ROI definition to begin matching by image comparison"
                    },
                    {
                        "name": "thresh",
                        "in": "query",
                        "type": "number",
                        "description": "For image ROIs, threshold value (0-100%) specifying what percentage of the pixels within\n                 the ROI must compare successfully to the expected ROI image to qualify as a match",
                        "default": 0.9
                    }
                ],
                "security": [],
                "tags": [
                    "roi"
                ]
            }
        },
        "/roi/add_roi_from_asset/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Name of ROI created and added",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Acquires a particular frame from the stream for an asset, creates a Region-Of-Interest (ROI) for that frame         (or some subset of it), and initiates matching for that ROI",
                "description": "SDK: `do_add_roi_from_asset()`\n\nNotes:\n * This is basically a dynamic mechanism to check if certain fragments of asset content are being played\n   in the current media stream.",
                "operationId": "do_add_roi_from_asset",
                "parameters": [
                    {
                        "name": "urlspec",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "URL describing the location of unified media content for the asset, or a pair\n                         (header, media) of URLs describing the asset media"
                    },
                    {
                        "name": "roi_name",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name to use for ROI created from frame"
                    },
                    {
                        "name": "thresh",
                        "in": "query",
                        "type": "number",
                        "description": "Threshold value (0-100%) specifying how closely each stream frame must resemble the\n                         target frame to qualify as a match",
                        "default": 0.9
                    },
                    {
                        "name": "region",
                        "in": "query",
                        "type": "string",
                        "description": "Region of frame to match ('upper-half' => upper half, None => entire frame)"
                    },
                    {
                        "name": "target_frame_num",
                        "in": "query",
                        "type": "integer",
                        "description": "Frame number within asset to use as match target",
                        "default": 29
                    }
                ],
                "security": [],
                "tags": [
                    "roi"
                ]
            }
        },
        "/roi/add_roi_from_image/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Name of generated ROI (None => could not create ROI)",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Generates a ROI from an image (or optionally, a portion thereof), and optionally initiates matching for that ROI",
                "description": "SDK: `do_add_roi_from_image()`",
                "operationId": "do_add_roi_from_image",
                "parameters": [
                    {
                        "name": "filespec",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "File specification of image file to use as a ROI"
                    },
                    {
                        "name": "roi_name",
                        "in": "query",
                        "type": "string",
                        "description": "Name to use for ROI created from frame (None => derive ROI name from specified filename)"
                    },
                    {
                        "name": "thresh",
                        "in": "query",
                        "type": "number",
                        "description": "Threshold value (0-100%) specifying how closely each stream frame must resemble the\n                 target frame to qualify as a match",
                        "default": 0.9
                    },
                    {
                        "name": "region",
                        "in": "query",
                        "type": "string",
                        "description": "Region of frame to match ('upper-half' => upper half, None => entire frame)"
                    },
                    {
                        "name": "match",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Start matching the newly defined ROI.\"",
                        "default": true
                    }
                ],
                "security": [],
                "tags": [
                    "roi"
                ]
            }
        },
        "/roi/match_rois/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Collection of all ROIs matched (empty => none matched)",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Determines which of the specified ROI(s) among the collection of ROIs currently being detected by BATS         in the device video stream have been matched",
                "description": "SDK: `do_match_rois()`\n\nNotes:\n * The ROI name(s) specified by `roi_names` are all presumed to have been added previously to the collection\n   of ROIs being detected by BATS via `add_roi()` or `add_ocr_roi()'.\n * If multiple ROI names are specified, this method tries to match all ROIs specified, and returns a\n   collection of matched ROIs.",
                "operationId": "do_match_rois",
                "parameters": [
                    {
                        "name": "roi_names",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name or collection of names of ROI(s) to check for a match in the playback stream\n                            (collection => check for multiple ROIs)"
                    },
                    {
                        "name": "interval",
                        "in": "query",
                        "type": "number",
                        "description": "Time interval (sec) at which to check for ROI match completion",
                        "default": 1
                    },
                    {
                        "name": "screenshot_interval",
                        "in": "query",
                        "type": "number",
                        "description": "Time interval (sec) at which to take screenshots (0 => no screenshots)",
                        "default": 5
                    },
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Timeout (sec) allowed for match check",
                        "default": 30
                    },
                    {
                        "name": "audio_video_check",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Also check that video and audio are not frozen.\"",
                        "default": false
                    }
                ],
                "security": [],
                "tags": [
                    "roi"
                ]
            }
        },
        "/roi/match_rois_with_scores/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Collection of pairs for all ROIs matched, in order matched (empty => no ROIs matched)\n          [0]: ROI name\n          [1]: Match proportion (0 .. 1)",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "array",
                                "items": {
                                    "type": "object"
                                }
                            }
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Submits a collection of ROIs to BATS for it to match in realtime against the incoming video stream for         a specified duration, using the specified matching threshold, returning all ROIs matched and the match degree         for each",
                "description": "SDK: `do_match_rois_with_scores()`",
                "operationId": "do_match_rois_with_scores",
                "parameters": [
                    {
                        "name": "roi_names",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name or collection of names of ROI(s) to check for a match in the stream\n                          (collection => check for multiple ROIs)"
                    },
                    {
                        "name": "thresh",
                        "in": "query",
                        "type": "number",
                        "description": "Threshold value (0-100%) specifying what percentage of the pixels within the ROI\n                          must compare successfully to the expected ROI image to qualify as a match",
                        "default": 0.9
                    },
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Timeout (sec) allowed for match check",
                        "default": 30
                    },
                    {
                        "name": "audio_video_check",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Also check that video and audio are not frozen.\"",
                        "default": false
                    }
                ],
                "security": [],
                "tags": [
                    "roi"
                ]
            }
        },
        "/roi/remove_roi/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "\"ROI removed successfully.\"",
                        "schema": {
                            "type": "boolean"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Removes a Region-Of-Interest (ROI) definition from the collection of ROIs currently being detected by BATS         in the device video stream",
                "description": "SDK: `do_remove_roi()`",
                "operationId": "do_remove_roi",
                "parameters": [
                    {
                        "name": "roi_name",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name of ROI definition to cease matching within BATS"
                    }
                ],
                "security": [],
                "tags": [
                    "roi"
                ]
            }
        },
        "/roi/set_roi_defs/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "ROI definition file contents",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Specifies the file defining all Regions-Of-Interest (ROIs) to detect in the video stream for this device,         and (optionally) returns the ROIs within that file",
                "description": "SDK: `set_roi_defs()`",
                "operationId": "set_roi_defs",
                "parameters": [
                    {
                        "name": "roi_defs_filespec",
                        "in": "query",
                        "type": "string",
                        "description": "File specification of ROI file to establish (None => previous or default ROI file);\n                          simple filename => within configured ROI definitions directory"
                    },
                    {
                        "name": "content",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Return BLOB containing ROIs content.\" (else return filespec where content is stored)",
                        "default": true
                    }
                ],
                "security": [],
                "tags": [
                    "roi"
                ]
            }
        },
        "/stb/file_grep/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "All occurrences of `pattern` found, newline-delimited (empty => no matches)",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Searches for the occurrence(s) of an arbitrary text pattern within an STB file, optionally following         a specified line number, and searching through a possible \"rollover\" file",
                "description": "SDK: `do_file_grep()`\n\nNotes:\n * This search algorithm supports files that can be growing or whose contents rotate to a \"rollover\" file;\n   searches the \"main\" file specified, but also the rollover file when rotation is detected.\n * Timeout for a failed search may actually be up to a few times the specified timeout due to retries.",
                "operationId": "do_file_grep",
                "parameters": [
                    {
                        "name": "pattern",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Regular expression specifying text pattern to search for (cannot span lines)"
                    },
                    {
                        "name": "filespec",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "File specification for file on STB to search"
                    },
                    {
                        "name": "rollover_ext",
                        "in": "query",
                        "type": "string",
                        "description": "File extension for first \"rollover\" file of `filespec` (None => file doesn't roll over)",
                        "default": ".1"
                    },
                    {
                        "name": "startline",
                        "in": "query",
                        "type": "integer",
                        "description": "Starting line number after which to search for the occurrence of `pattern`\n                     (must be < number of lines in file, or a \"rollover\" is assumed)",
                        "default": 0
                    },
                    {
                        "name": "options",
                        "in": "query",
                        "type": "string",
                        "description": "Additional command-line options for `grep` command"
                    },
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Timeout period (sec) allowed for (repeated) search (None => unlimited duration)",
                        "default": 30
                    }
                ],
                "security": [],
                "tags": [
                    "stb"
                ]
            }
        },
        "/stb/navigate_deeplink/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Response from XAPI",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Sends a \"deeplink\" HTTP request to the XAPI pertaining to this device",
                "description": "SDK: `do_navigate_deeplink()`\n\nNotes:\n * Specified `params` are included as query parameters for GET requests and as form data for POST requests.\n * This resource is solely for accessing XAPI deeplinks verbatim; no processing or filtering of query parameters\n   or request data is performed.\n * For specific information about the deeplinks available through the XAPI, see:\n   https://etwiki.sys.comcast.net/pages/viewpage.action?spaceKey=xcalPDEV&title=XAPI+Service++Specification\n   and https://etwiki.sys.comcast.net/pages/viewpage.action?spaceKey=X2TP&title=X2+Deeplinks",
                "operationId": "do_navigate_deeplink",
                "parameters": [
                    {
                        "name": "deeplink",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "XAPI deeplink URL to invoke (not validated for correctness by this resource): full URL,\n                 including 'xre' scheme"
                    },
                    {
                        "name": "method",
                        "in": "query",
                        "type": "string",
                        "description": "HTTP method (GET or POST)",
                        "default": "get"
                    },
                    {
                        "name": "params",
                        "in": "query",
                        "type": "string",
                        "description": "Dictionary of query parameters or data to qualify the deeplink (None => no parameters)"
                    }
                ],
                "security": [],
                "tags": [
                    "stb"
                ]
            }
        },
        "/stb/receiver_trace_id/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Most recent trace ID extracted from receiver logs (None => no trace ID found)",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Extracts the most recent trace ID from the receiver log on the STB device",
                "description": "SDK: `get_receiver_trace_id()`",
                "operationId": "get_receiver_trace_id",
                "parameters": [
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Timeout period (sec) allowed for trace ID to be extracted (None => unlimited duration)",
                        "default": 60
                    }
                ],
                "security": [],
                "tags": [
                    "stb"
                ]
            }
        },
        "/stb/restart_receiver/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "\"Restarted successfully.\"  (otherwise, no positive indication of success detected)",
                        "schema": {
                            "type": "boolean"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Interacts with STB device to cause it to restart its internal receiver module",
                "description": "SDK: `do_restart_receiver()`\n\nNotes:\n * Executes synchronously, not returning until receiver is (presumably) restarted.",
                "operationId": "do_restart_receiver",
                "parameters": [
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Timeout period (sec), within which restart is expected to complete",
                        "default": 300
                    }
                ],
                "security": [],
                "tags": [
                    "stb"
                ]
            }
        },
        "/stb/session_close/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Closes an open pexpect shell session on this STB device",
                "description": "SDK: `do_session_close()`",
                "operationId": "do_session_close",
                "security": [],
                "tags": [
                    "stb"
                ]
            }
        },
        "/stb/session_open/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Command-line prompt from STB device (empty => session creation failure)",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Opens a pexpect shell session on this STB device",
                "description": "SDK: `do_session_open()`\n\nNotes:\n * Do not specify an `inactivity_timeout` value of 0 unless you know exactly what you are doing.\n   (Sessions sitting idle in perpetuity consume a Jump Server session from its quota.)\n * Side-effect: saves opened session in this object.",
                "operationId": "do_session_open",
                "parameters": [
                    {
                        "name": "allow_fail",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Don't raise PlayerDeviceError upon failure to establish a session.\"",
                        "default": false
                    },
                    {
                        "name": "connection_attempts",
                        "in": "query",
                        "type": "integer",
                        "description": "Maximum number of times to attempt to open a session to the STB before failing out",
                        "default": 3
                    },
                    {
                        "name": "inactivity_timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Maximum duration between shell commands or output production\n                            tolerated before automatically closing session (sec); 0 => no timeout",
                        "default": 600
                    }
                ],
                "security": [],
                "tags": [
                    "stb"
                ]
            }
        },
        "/stb/shell_command/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Output from shell command",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Executes an arbitrary shell command on this STB",
                "description": "SDK: `do_shell_command()`\n\nNotes:\n * The existing shell session is used, if currently open; otherwise, a new temporary shell session,\n   lasting only for the duration of this command, is opened then closed.",
                "operationId": "do_shell_command",
                "parameters": [
                    {
                        "name": "cmd",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Command line to execute at interactive STB shell prompt"
                    },
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Timeout period (sec) allowed for shell command to execute on STB\n                (None => unlimited duration)"
                    },
                    {
                        "name": "retries",
                        "in": "query",
                        "type": "integer",
                        "description": "Number of times to retry a command on the STB if it fails",
                        "default": 0
                    }
                ],
                "security": [],
                "tags": [
                    "stb"
                ]
            }
        },
        "/stb/xapi_command/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Response from XAPI",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Issues a generic HTTP request \"command\" to the XRE API (XAPI), optionally pertaining to this device",
                "description": "SDK: `do_xapi_command()`\n\nNotes:\n * HTTP GET and POST methods are supported by XAPI.\n * Specified `params` are included as query parameters for GET requests and as form data for POST requests.\n * This resource is solely for passing XAPI requests through verbatim; no processing or filtering of query\n   parameters or request data is performed.\n * For specific information about the requests available through the XAPI and their endpoints, see:\n   https://etwiki.sys.comcast.net/pages/viewpage.action?spaceKey=xcalPDEV&title=XAPI+Service++Specification",
                "operationId": "do_xapi_command",
                "parameters": [
                    {
                        "name": "endpoint",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "XAPI endpoint name to invoke (simple name, without .js; correctness not validated by EAPI)"
                    },
                    {
                        "name": "method",
                        "in": "query",
                        "type": "string",
                        "description": "HTTP method (GET or POST)",
                        "default": "get"
                    },
                    {
                        "name": "params",
                        "in": "query",
                        "type": "string",
                        "description": "Dictionary containing query parameters or data to accompany request (None => no parameters)"
                    },
                    {
                        "name": "device",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Device-specific request.\"  (else not specific to any device)",
                        "default": true
                    }
                ],
                "security": [],
                "tags": [
                    "stb"
                ]
            }
        },
        "/stb/xapi_status/{slot_id}": {
            "parameters": [
                {
                    "description": "Slot ID for device as accessible to server",
                    "name": "slot_id",
                    "in": "path",
                    "required": true,
                    "type": "string"
                }
            ],
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "JSON result from XAPI `checkalive` endpoint",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "HTTPStatus.NOT_FOUND": {
                        "description": "Device not reserved"
                    }
                },
                "summary": "Retrieves the XAPI status for this device",
                "description": "SDK: `get_xapi_status()`",
                "operationId": "get_xapi_status",
                "security": [],
                "tags": [
                    "stb"
                ]
            }
        },
        "/test/client_spoof": {
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "New (spoofed) client name (derived from actual name)",
                        "schema": {
                            "type": "string"
                        }
                    }
                },
                "summary": "Initiates or cancels client spoofing, allowing a specified (or the requesting) client to masquerade as         a different client for testing purposes",
                "description": "SDK: `do_client_spoof()`",
                "operationId": "do_client_spoof",
                "parameters": [
                    {
                        "name": "client_name",
                        "in": "query",
                        "type": "string",
                        "description": "Name (client ID public portion) of client (None => requesting client)"
                    },
                    {
                        "name": "new_name",
                        "in": "query",
                        "type": "string",
                        "description": "New client ID name to masquerade as\n                    (`client_name` => cancel spoofing for client, None => generate from actual client name)"
                    }
                ],
                "security": [],
                "tags": [
                    "test"
                ]
            }
        },
        "/test/file_download": {
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "File content (base64-encoded if `content` and `is_binary`)",
                        "schema": {
                            "type": "object"
                        }
                    }
                },
                "summary": "Downloads a file or its contents from this server",
                "description": "SDK: `get_file_download()`\n\nNotes:\n * CAUTION! This is insecure: file access from the server is unrestricted; any server file accessible by the\n   BATS deployment user can be retrieved, including sensitive files.\n * Current directory on the server side is the EAPI launch directory.\n * File content transfer is via HTTP, so large transfers will be very slow.",
                "operationId": "get_file_download",
                "parameters": [
                    {
                        "name": "server_filespec",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "File specification of a file on the server system to download"
                    },
                    {
                        "name": "content",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Return file content as simple result.\" (else return content as savable HTTP attachment)",
                        "default": false
                    },
                    {
                        "name": "is_binary",
                        "in": "query",
                        "type": "boolean",
                        "description": "(`content`==True) \"Return base64-encoded result.\"",
                        "default": false
                    }
                ],
                "security": [],
                "tags": [
                    "test"
                ]
            }
        },
        "/test/file_upload": {
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    }
                },
                "summary": "Uploads a file to this server from an existing file on the client system (or from specified content)",
                "description": "SDK: `do_file_upload()`\n\nNotes:\n * CAUTION! This is dangerous: file destination on the server is unrestricted; inadvertently overwriting\n   an important file can damage the EAPI deployment or other server files.\n * Current directory on the server side is the EAPI launch directory.\n * File content transfer is via HTTP, so large transfers will be very slow.",
                "operationId": "do_file_upload",
                "parameters": [
                    {
                        "name": "server_filespec",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "File specification of a file on the server system to upload to"
                    },
                    {
                        "name": "overwrite",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Overwrite file on server if it exists.\"",
                        "default": false
                    },
                    {
                        "name": "client_file",
                        "in": "formData",
                        "type": "file",
                        "description": "File content of a file on the client system to upload (unspecified => upload `content`)"
                    },
                    {
                        "name": "content",
                        "in": "query",
                        "type": "string",
                        "description": "Base64 representation of file content (None => upload `client_file`)"
                    },
                    {
                        "name": "is_binary",
                        "in": "query",
                        "type": "boolean",
                        "description": "(`content` specified) \"Content is base64-encoded.\"",
                        "default": false
                    }
                ],
                "security": [],
                "consumes": [
                    "multipart/form-data"
                ],
                "tags": [
                    "test"
                ]
            }
        },
        "/test/module_assign": {
            "post": {
                "responses": {
                    "HTTPStatus.NO_CONTENT": {
                        "description": "Success"
                    }
                },
                "summary": "Assigns a module variable or (sub)class attribute within a module namespace to a specified value",
                "description": "SDK: `do_module_assign()`\n\nNotes:\n * This exists only to support internal EAPI verification and validation, not intended for client use.",
                "operationId": "do_module_assign",
                "parameters": [
                    {
                        "name": "target_module",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name of server-side module to assign a module variable within"
                    },
                    {
                        "name": "target_var",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name of target module variable to assign (dot-delimited => subobject references)"
                    },
                    {
                        "name": "source_val",
                        "in": "query",
                        "type": "string",
                        "description": "Value, or name within `source_module` containing value:\n                       - `source_module` absent => presumed JSON, otherwise raw string\n                       - `source_module` provided => name to resolve (dot-delimited => subobject references)\n                                                     (None => same as `target_var`)"
                    },
                    {
                        "name": "source_module",
                        "in": "query",
                        "type": "string",
                        "description": "Name of server-side module to look up `source_val` within (None => literal `source_val`)"
                    }
                ],
                "security": [],
                "tags": [
                    "test"
                ]
            }
        },
        "/test/module_call": {
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "JSON-serialized function result, if possible, otherwise result string, if any (None => no result)",
                        "schema": {
                            "type": "string"
                        }
                    }
                },
                "summary": "Calls a server-side module-global function or class/static method, optionally passing a specified or referenced argument value, and returns the function result, if any",
                "description": "SDK: `do_module_call()`\n\nNotes:\n * This exists only to support internal EAPI verification and validation, not intended for client use.",
                "operationId": "do_module_call",
                "parameters": [
                    {
                        "name": "module",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Module where function/method is defined"
                    },
                    {
                        "name": "funcname",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Fully-qualified function/method name (dot-delimited => class/subclass references)"
                    },
                    {
                        "name": "arg",
                        "in": "query",
                        "type": "string",
                        "description": "Value, or name within `arg_module` containing argument value (None => no argument passed)\n                     - `source_module` absent => presumed JSON, otherwise raw string\n                     - `source_module` provided => name to resolve (dot-delimited => subobject references)\n                                                   (None => same as `target_var`)"
                    },
                    {
                        "name": "arg_module",
                        "in": "query",
                        "type": "string",
                        "description": "Name of server-side module to look up `source_val` within (None => literal `source_val`)"
                    }
                ],
                "security": [],
                "tags": [
                    "test"
                ]
            }
        },
        "/test/module_import": {
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Name of module imported",
                        "schema": {
                            "type": "string"
                        }
                    }
                },
                "summary": "(Re-)imports an existing server-side runtime module within the specified server-side parent module",
                "description": "SDK: `do_module_import()`\n\nNotes:\n * This exists only to support internal EAPI verification and validation, not intended for client use.",
                "operationId": "do_module_import",
                "parameters": [
                    {
                        "name": "module",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name of module to import (fully-qualified, reachable on existing system path)"
                    },
                    {
                        "name": "within",
                        "in": "query",
                        "type": "string",
                        "description": "Parent module within which to import `module` (None => import globally)"
                    },
                    {
                        "name": "alias",
                        "in": "query",
                        "type": "string",
                        "description": "Module alias within parent module (None => use `module` as name)"
                    }
                ],
                "security": [],
                "tags": [
                    "test"
                ]
            }
        },
        "/test/module_value": {
            "get": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Value retrieved (JSON representation), if possible",
                        "schema": {
                            "type": "string"
                        }
                    }
                },
                "summary": "Retrieves the value of a module variable or (sub)class attribute within a module namespace",
                "description": "SDK: `get_module_value()`\n\nNotes:\n * Can only retrieve a variable value that is a primitive Python data or container type.",
                "operationId": "get_module_value",
                "parameters": [
                    {
                        "name": "module",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name of server-side module to retrieve a module/class variable from"
                    },
                    {
                        "name": "var",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Name of server-side module variable to retrieve (dot-delimited => subobject references)"
                    }
                ],
                "security": [],
                "tags": [
                    "test"
                ]
            }
        },
        "/test/shell_command": {
            "post": {
                "responses": {
                    "HTTPStatus.OK": {
                        "description": "Output from shell command (unstripped: includes all EOLs); `tolerant` => first line is exit code",
                        "schema": {
                            "type": "string"
                        }
                    }
                },
                "summary": "Executes an arbitrary shell command on this server",
                "description": "SDK: `do_shell_command()`\n\nNotes:\n * CAUTION! With power comes responsibility: use the same care and discretion as would befit execution\n   of commands from an SSH shell opened on the server.\n * Current directory is the EAPI launch directory, and current user is the BATS deployment user (not root).",
                "operationId": "do_shell_command",
                "parameters": [
                    {
                        "name": "cmd",
                        "in": "query",
                        "type": "string",
                        "required": true,
                        "description": "Command line to execute at interactive server shell prompt"
                    },
                    {
                        "name": "timeout",
                        "in": "query",
                        "type": "number",
                        "description": "Timeout period (sec) allowed for shell command to execute (None => unlimited duration)"
                    },
                    {
                        "name": "tolerant",
                        "in": "query",
                        "type": "boolean",
                        "description": "\"Tolerate any command execution error and always output exit code as first line.\"\n                 (else generate exception in case of error)",
                        "default": false
                    }
                ],
                "security": [],
                "tags": [
                    "test"
                ]
            }
        }
    },
    "info": {
        "title": "EAPI (localhost)",
        "version": "0.16.0",
        "description": "EA Player Device Testing/Stream Auditing API for BATS"
    },
    "produces": [
        "application/json"
    ],
    "consumes": [
        "application/json"
    ],
    "securityDefinitions": {
        "basic": {
            "type": "basic"
        },
        "apikey": {
            "type": "apiKey",
            "in": "header",
            "name": "Authorization"
        }
    },
    "tags": [
        {
            "name": "manager",
            "description": "EAPI resource group: Operations related to EAPI server management."
        },
        {
            "name": "manager/device",
            "description": "EAPI resource group: Operations related to BATS player device management."
        },
        {
            "name": "device",
            "description": "EAPI resource group: Operations related to universal device control in common across all player device categories."
        },
        {
            "name": "stb",
            "description": "EAPI resource group: Operations related to set-top box-specific actions."
        },
        {
            "name": "analysis",
            "description": "EAPI resource group: Operations related to analysis of media playback stream/signal."
        },
        {
            "name": "quality",
            "description": "EAPI resource group: Operations related to quality measurements of media playback stream/signal by SSIMWAVE"
        },
        {
            "name": "roi",
            "description": "EAPI resource group: Operations related to frame region-of-interest processing."
        },
        {
            "name": "outcome",
            "description": "EAPI resource group: Operations related to stream analysis/auditing activity outcomes and artifacts."
        },
        {
            "name": "test",
            "description": "EAPI resource group: Operations related to internal EAPI testing and instrumentation."
        }
    ],
    "definitions": {
        "ServerInformation": {
            "properties": {
                "IsRemote": {
                    "type": "boolean",
                    "description": "\"EAPI Service is hosted on a BATS server.\""
                },
                "EAPI": {
                    "type": "object",
                    "description": "EAPI Service Information"
                },
                "BATSCore": {
                    "type": "object",
                    "description": "BATS Core Information"
                },
                "Capabilities": {
                    "type": "object",
                    "description": "EAPI/BATS Core Capabilities"
                },
                "UpTime": {
                    "type": "integer",
                    "description": "Time (sec) since EAPI Service started"
                },
                "LastRequest": {
                    "type": "integer",
                    "description": "Time (sec) since last request completion (- if no requests)"
                }
            },
            "type": "object"
        },
        "DeviceDefinition": {
            "properties": {
                "lab": {
                    "type": "string",
                    "description": "Lab (site/facility) where device resides (None => N/A)"
                },
                "server": {
                    "type": "string",
                    "description": "Server system having slot for device attachment (None => no HDMI attachment)"
                },
                "slot_id": {
                    "type": "string",
                    "description": "Slot ID for device as accessible to server"
                },
                "category": {
                    "type": "string",
                    "description": "Player device category (one of: {'STB', 'SSP', 'VSP', 'Gateway'})"
                },
                "name": {
                    "type": "string",
                    "description": "Make/Model/Version of player device"
                },
                "description": {
                    "type": "string",
                    "description": "Description of device make/model/version"
                },
                "partner": {
                    "type": "string",
                    "description": "Partner providing device/firmware (None => Comcast)"
                },
                "web_stream": {
                    "type": "string",
                    "description": "Web path for device output stream"
                },
                "video": {
                    "type": "string",
                    "description": "System device name for video device (vacuous => virtual device)"
                },
                "audio": {
                    "type": "string",
                    "description": "System audio channel for audio device"
                },
                "url": {
                    "type": "string",
                    "description": "URL of input stream for virtual device (vacuous => real device)"
                },
                "xray_id": {
                    "type": "string",
                    "description": "[STB] Device ID code in X-Ray for device"
                },
                "xray_model": {
                    "type": "string",
                    "description": "[STB] Model ID code in X-Ray for device"
                },
                "ecm_mac": {
                    "type": "string",
                    "description": "[Gateway] eCM MAC address for Gateway device (:-delimited) (vacuous => N/A)"
                },
                "estb_mac": {
                    "type": "string",
                    "description": "[STB] eSTB MAC address for device (:-delimited) (vacuous => N/A)"
                },
                "estb_ip": {
                    "type": "string",
                    "description": "[STB] IPv6 address address for device (:-delimited) (vacuous => N/A)"
                },
                "platform": {
                    "type": "string",
                    "description": "[SSP] Execution platform for device"
                },
                "hostname": {
                    "type": "string",
                    "description": "[SSP] Network hostname/IP of SSPC hub for device"
                },
                "port": {
                    "type": "integer",
                    "description": "[SSP] Network port of SSPC host driver for device"
                },
                "capabilities": {
                    "type": "string",
                    "description": "[SSP] File or JSON BLOB describing SSP capabilities (vacuous => SSP device type defaults)"
                },
                "offline": {
                    "type": "boolean",
                    "description": "Whether device is offline (true) or available (false)"
                },
                "reservation": {
                    "type": "string",
                    "description": "Reservation for device (vacuous => unreserved)"
                },
                "message": {
                    "type": "string",
                    "description": "Failure reason"
                }
            },
            "type": "object"
        },
        "DeviceServiceStatus": {
            "properties": {
                "slot_id": {
                    "type": "string",
                    "description": "Slot ID for device"
                },
                "client_id": {
                    "type": "string",
                    "description": "Client ID of this requestor"
                },
                "reserver": {
                    "type": "string",
                    "description": "Client ID of client holding reservation (empty if unreserved)"
                },
                "initialized": {
                    "type": "boolean",
                    "description": "\"Testing/auditing session has been initialized on device.\""
                },
                "started": {
                    "type": "boolean",
                    "description": "\"BATS Core analysis session has been started on device.\""
                },
                "executing": {
                    "type": "string",
                    "description": "Name of resource currently executing on device (empty if service is idle)"
                },
                "lifetime": {
                    "type": "integer",
                    "description": "Time (sec) resource has been executing on device (0 if N/A) "
                }
            },
            "type": "object"
        },
        "DeviceSettings": {
            "properties": {
                "cc": {
                    "type": "boolean",
                    "description": "Closed-captioning enablement state (\"truthy\" value: 0=>disabled, 1=>enabled)"
                },
                "cc_font_size": {
                    "type": "string",
                    "description": "Closed-captioning font size -- one of: ['MEDIUM', 'LARGE', 'SMALL']"
                },
                "cc_font_style": {
                    "type": "string",
                    "description": "Closed-captioning text style -- one of: ['DEFAULT', 'CASUAL', 'MONOSPACED_SERIF']"
                },
                "cc_font_color": {
                    "type": "string",
                    "description": "Closed-captioning font color -- one of: ['WHITE', 'BLACK', 'RED', 'GREEN', 'BLUE', 'YELLOW']"
                },
                "cc_font_opacity": {
                    "type": "string",
                    "description": "Closed-captioning font opacity -- one of: ['SOLID', 'TRANSPARENT', 'TRANSLUCENT']"
                },
                "cc_font_edge_style": {
                    "type": "string",
                    "description": "Closed-captioning font edge style -- one of: ['NONE', 'RAISED', 'DEPRESSED', 'UNIFORM']"
                },
                "cc_font_edge_color": {
                    "type": "string",
                    "description": "Closed-captioning font edge color -- one of: ['BLACK', 'RED', 'GREEN', 'BLUE', 'YELLOW', 'WHITE']"
                },
                "cc_background_color": {
                    "type": "string",
                    "description": "Closed-captioning background color -- one of: ['BLACK', 'RED', 'BLUE', 'YELLOW', 'WHITE']"
                },
                "cc_background_opacity": {
                    "type": "string",
                    "description": "Closed-captioning background opacity -- one of: ['SOLID', 'TRANSPARENT', 'TRANSLUCENT']"
                },
                "window_color": {
                    "type": "string",
                    "description": "Closed-captioning window color -- one of: ['BLACK', 'RED', 'GREEN', 'BLUE', 'YELLOW', 'WHITE']"
                },
                "window_opacity": {
                    "type": "string",
                    "description": "Closed-captioning window opacity -- one of: ['TRANSPARENT', 'TRANSLUCENT', 'SOLID']"
                },
                "attr_type": {
                    "type": "string",
                    "description": "Closed-captioning attribute type -- one of: ['DIGITAL', 'ANALOG']"
                },
                "sap": {
                    "type": "boolean",
                    "description": "Secondary Audio Program enablement state (\"truthy\" value)"
                },
                "saplang": {
                    "type": "string",
                    "description": "Secondary Audio Program language selected (must be in current asset profile)"
                },
                "guidelang": {
                    "type": "string",
                    "description": "Guide screen language selected"
                },
                "voiceguide": {
                    "type": "boolean",
                    "description": "Voice guidance enablement state (\"truthy\" value: 0=>disabled, 1=>enabled)"
                },
                "dvs": {
                    "type": "boolean",
                    "description": "Video description enablement state (\"truthy\" value: 0=>disabled, 1=>enabled)"
                },
                "hdpref": {
                    "type": "boolean",
                    "description": "HD Auto-Retune enablement state (\"truthy\" value: 0=>disabled, 1=>enabled)"
                },
                "sstimeout": {
                    "type": "integer",
                    "description": "Screen Saver Inactivity timeout (sec) -- one of: [300, 900, 1800, 18000, 0], 0=>no screensaver"
                }
            },
            "type": "object"
        },
        "AnalyzerSettings": {
            "properties": {
                "color_tolerance": {
                    "type": "integer",
                    "description": "Color \"distance\" (three-color 8-bit absolute) <= which pixels deemed \"identical\""
                },
                "black_threshold": {
                    "type": "integer",
                    "description": "Grayscale threshold (8-bit) <= which a pixel deemed \"black\""
                },
                "same_image_threshold": {
                    "type": "number",
                    "description": "Threshold, % \"same\" pixels >= which two images deemed \"identical\""
                },
                "frozen_threshold": {
                    "type": "integer",
                    "description": "Threshold, # consecutive \"identical\" frames >= which video stream deemed \"frozen\""
                },
                "silence_threshold": {
                    "type": "integer",
                    "description": "Audio level threshold (16-bit absolute) <= which audio deemed \"silent\""
                },
                "amplitude_tolerance": {
                    "type": "integer",
                    "description": "Audio amplitude tolerance (15-bit absolute delta) <= which audio samples deemed \"identical\""
                },
                "temporal_tolerance": {
                    "type": "integer",
                    "description": "Audio sample window, absolute delta <= which audio sample comparison for \"identical\" occurs"
                },
                "same_sound_threshold": {
                    "type": "number",
                    "description": "Threshold, % \"same\" samples >= which audio clips deemed \"identical\""
                },
                "mute_threshold": {
                    "type": "integer",
                    "description": "Threshold, # consecutive \"silent\" audio clips >= which audio stream deemed \"mute\""
                }
            },
            "type": "object"
        },
        "VideoSignalStatus": {
            "properties": {
                "signal_state": {
                    "type": "integer",
                    "description": "Current state of video input signal:\n0 => NO_SIGNAL\n1 => INVALID_SIGNAL\n2 => UNLOCKED_SIGNAL\n3 => SIGNAL_OK"
                },
                "width": {
                    "type": "integer",
                    "description": "Frame resolution width (pixels)"
                },
                "height": {
                    "type": "integer",
                    "description": "Frame resolution height (pixels)"
                },
                "frame_freq": {
                    "type": "number",
                    "description": "Frame capture frequency (Hz)"
                },
                "color_format": {
                    "type": "integer",
                    "description": "Color format for video input signal:\n0 => UNKNOWN\n1 => RGB\n2 => YUV601\n3 => YUV709\n4 => YUV2020\n5 => YUV2020C"
                },
                "is_interlaced": {
                    "type": "boolean",
                    "description": "\"Stream is interlaced (resulting in halved frame capture frequency).\""
                },
                "is_hdcp": {
                    "type": "boolean",
                    "description": "\"HDCP encryption in use on video input signal.\""
                }
            },
            "type": "object"
        },
        "AudioSignalStatus": {
            "required": [
                "is_lpcm",
                "num_channels",
                "sample_freq",
                "sample_size_bits",
                "signal_state"
            ],
            "properties": {
                "signal_state": {
                    "type": "integer",
                    "description": "Current state of audio input signal (>0 => enabled)"
                },
                "num_channels": {
                    "type": "integer",
                    "description": "Number of audio channels (2 => stereo)"
                },
                "sample_freq": {
                    "type": "integer",
                    "description": "Audio sampling frequency (Hz)"
                },
                "sample_size_bits": {
                    "type": "integer",
                    "description": "Audio sample size (bits per sample)"
                },
                "is_lpcm": {
                    "type": "boolean",
                    "description": "\"Audio samples are LPCM (linear PCM).\""
                }
            },
            "type": "object"
        },
        "VideoStats": {
            "properties": {
                "total_frames": {
                    "type": "integer",
                    "description": "Total # frames analyzed"
                },
                "total_batches": {
                    "type": "integer",
                    "description": "Number of backlog batches processed"
                },
                "max_backlog": {
                    "type": "integer",
                    "description": "Maximum # frames accumulated in backlog"
                },
                "total_identical": {
                    "type": "integer",
                    "description": "Total # frames \"identical\" to previous in stream"
                },
                "max_identical": {
                    "type": "integer",
                    "description": "Maximum # consecutive frames \"identical\" to previous in stream"
                },
                "total_black": {
                    "type": "integer",
                    "description": "Total # video frames deemed \"black\""
                },
                "max_black": {
                    "type": "integer",
                    "description": "Maximum # consecutive video frames deemed \"black\""
                },
                "total_frames_lost": {
                    "type": "integer",
                    "description": "Total # available video frames uncaptured"
                },
                "max_frames_lost": {
                    "type": "integer",
                    "description": "Maximum # consecutive video frames uncaptured"
                }
            },
            "type": "object"
        },
        "AudioStats": {
            "properties": {
                "total_frames": {
                    "type": "integer",
                    "description": "Total # frames analyzed"
                },
                "total_batches": {
                    "type": "integer",
                    "description": "Number of backlog batches processed"
                },
                "max_backlog": {
                    "type": "integer",
                    "description": "Maximum # frames accumulated in backlog"
                },
                "total_identical": {
                    "type": "integer",
                    "description": "Total # frames \"identical\" to previous in stream"
                },
                "max_identical": {
                    "type": "integer",
                    "description": "Maximum # consecutive frames \"identical\" to previous in stream"
                },
                "total_silent": {
                    "type": "integer",
                    "description": "Total # audio frames deemed \"silent\""
                },
                "max_silent": {
                    "type": "integer",
                    "description": "Maximum # consecutive audio frames deemed \"silent\""
                },
                "total_samples": {
                    "type": "integer",
                    "description": "Total # individual audio samples processed"
                },
                "amplitude_min": {
                    "type": "integer",
                    "description": "Maximum negative amplitude among all audio samples"
                },
                "amplitude_max": {
                    "type": "integer",
                    "description": "Maximum positive amplitude among all audio samples"
                },
                "total_frames_lost": {
                    "type": "integer",
                    "description": "Total # available audio frames uncaptured"
                },
                "max_frames_lost": {
                    "type": "integer",
                    "description": "Maximum # consecutive audio frames uncaptured"
                }
            },
            "type": "object"
        },
        "SpokenLanguageInfo": {
            "properties": {
                "service_status": {
                    "type": "string",
                    "description": "Status indication from language analysis service (COMPLETED => ok)"
                },
                "language_code": {
                    "type": "string",
                    "description": "ISO language code of spoken language (None => unknown/indeterminate)"
                },
                "language_name": {
                    "type": "string",
                    "description": "Language name of spoken language (None => unknown/indeterminate)"
                },
                "analysis_confidence": {
                    "type": "number",
                    "description": "Confidence % for language analysis"
                }
            },
            "type": "object"
        }
    },
    "responses": {
        "ParseError": {
            "description": "When a mask can't be parsed"
        },
        "MaskError": {
            "description": "When any error occurs on mask"
        }
    }
}
